<search>
    
     <entry>
        <title>Posts</title>
        <url>http://xuzhibin.com/post/</url>
        <categories>
          
        </categories>
        <tags>
          
        </tags>
        <content type="html"> </content>
    </entry>
    
     <entry>
        <title>博客转为hugo</title>
        <url>http://xuzhibin.com/post/2019/hugo-install/</url>
        <categories>
          <category>tools</category>
        </categories>
        <tags>
          <tag>hugo</tag>
        </tags>
        <content type="html"> hexo生成速度越来越慢了，决定转为hugo，hugo安装使用简单，不过模板数量和质量的确和hexo有差距。
hugo生成速度非常快，以前hexo生成站点要10几秒，hugo在1秒以内。
安装 Hugo中文文档
Next模板
Hugo 从入门到会用
配置 将模板下的config.toml复制到根目录修改即可
运行 hugo server 浏览器里打开： http://localhost:1313
生成 hugo 会在根目录下生成public目录
生成静态网站时，hugo 会忽略所有通过 draft: true 标记为草稿的文件。必须改为 draft: false 才会编译进 HTML 文件。
发布 将根目录下生成的public目录上传至服务器即可
FAQ 代码高亮 highlight.js这个插件使用起来特别方便，还可以定制化选择需要高亮的语言，只需要在highlight.js官网选择所需要的语言，下载即可。然后解压文件中，highlight.pack.js决定那些语言的代码会根据语法进行高亮，在style文件夹中选择喜欢的css样式文件，css文件决定代码高亮的颜色，最后我选择了github-gist.css
然后需要在中增加：
&amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;/path/to/styles/default.css&amp;#34;&amp;gt; 在结束前增加：
&amp;lt;script src=&amp;#34;/path/to/highlight.pack.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt;hljs.initHighlightingOnLoad();&amp;lt;/script&amp;gt; 内容截断 只需要在需要进行分隔的地方添加一个&amp;lt;!--more--&amp;gt;标签即可，这样标签后面的内容则需要点Read more才可完全显示。
评论 使用Gitment实现
Hugo集成Gitment评论插件
解决gitment无法登陆评论问题（Object ProgressEvent）
Hexo 添加 Gitment 评论
完美替代多说-gitment
</content>
    </entry>
    
     <entry>
        <title>React &#43; Electron 搭建一个桌面应用[转]</title>
        <url>http://xuzhibin.com/post/2018/electron-react/</url>
        <categories>
          <category>前端</category>
        </categories>
        <tags>
          <tag>electron</tag><tag>react</tag>
        </tags>
        <content type="html"> 当你冲这个标题点进来的时候，我猜你一定知道 React 是什么，更多详情请戳这里，就不介绍React了，一个神般存在的前端框架。另外，浏览器和移动端横行的时代，为什么还需要桌面应用？我就不解释了，反正优点很多，做为技术多学一点总没错。
Electron 简单介绍 是什么? 官网是这么介绍的：
Electronis an open source library developed by GitHub for building cross-platform desktop applications with HTML, CSS, and JavaScript. Electron accomplishes this by combining Chromiumand Node.jsinto a single runtime and apps can be packaged for Mac, Windows, and Linux.
简单翻译一下就是：
​Electron是一个由 GitHub 开发的开源库，通过将 Chromium) 和Node.js组合并使用 HTML，CSS 和 JavaScript 进行构建 Mac，Windows，和 Linux 跨平台桌面应用程序。
隐藏意思：
让前端开发者快乐简单拥抱桌面应用！
原理是? 上面已将说了，Electron通过将 Chromium和 Node.js组合到单个 runtime 中来实现的。
node.js:
如果你不知道 node.js，那还等什么快戳这里，看一看世界上最温柔可爱的语言。它借助于 Google 的 V8 引擎，Node.js是一个能够在服务器端运行 JavaScript 的开放源代码、跨平台 JavaScript 运行环境，更多解释请戳维基百科。
Chromium:
Chromium 或许你没听说过，但是你一定听说过 chrome 吧！Chromium 是 Google 的开源浏览器，是 chrome 背后的那个不太稳定更新快的兄弟版，详情戳这里。
组合:
Electron 创建的应用使用网页作为其 GUI ,因此你可以将其当成由 JavaScript 控制的迷你精简版Chromium 浏览器。也可以将 Electron 当成 node.js 变体，只不过它更专注于桌面应用而非 Web 服务器。在 Electron 中, 把 package.json中设定的 main脚本的所在进程称为 主进程。这个进程中运行的脚本也可通过创建网页这种方式来展现其 GUI。 因为 Electron 是通过 Chromium 来显示页面,所以 Chromium 自带的多进程架构也一同被利用。这样每个页面都运行着一个独立的进程,它们被统称为 渲染进程。通常来说,浏览器中的网页会被限制在沙盒环境中运行并且不允许访问系统原生资源。但是由于 Eelectron 用户可在页面中调用 Node.js API，所以可以和底层操作系统直接交互。
优缺点？ 总之，优点肯定大于缺点。
优点:
方便快捷的开发桌面应用，跨平台，对前端开发者友好，活跃的社区，丰富的api&amp;hellip;&amp;hellip;
缺点:
性能肯定比不上原生的桌面应用，发布的包貌似有一点点大。
怎么开始? 如果不是假前端，那么你电脑肯定安装好了 git 和 node。
# github上有一个 electron-quick-start 仓库克隆下来 git clone https://github.com/electron/electron-quick-start # 进入文件夹 cd electron-quick-start # 安装依赖包并运行 npm install &amp;amp;&amp;amp; npm start 然后，你桌面应用就创建成功了如下图所示！
打开你的 electron-quick-start 文件夹，你的项目结构如下图：
其中，main.js 是你的启动文件，index.html 是你的入口文件。
React 结合 Electron 上面简单的介绍了一下 Electron，下面介绍一下如何将 React 和 Electron 结合起来。
创建一个React项目 首先你得有一个 React 项目，由于太多繁琐的配置和懒惰的自己，我们这里就用 Facebook 提供的 create-react-app 来快速创建一个 knownsec-fed 项目。
# 安装 create-react-app 命令,如果已将安装请忽略 npm install -g create-react-app # 创建 knownsec-fed 项目 create-react-app knownsec-fed # 启动项目( create-react-app 真的超级方便啊) cd knownsec-fed &amp;amp;&amp;amp; npm start 于是，浏览器 http://localhost:3000/ 就会出现着如下图界面，一个 react 项目创建成功：
添加 Electron 包 # 在knownsec-fed 目录下安装 Electron 包 npm install -save electron 相关配置 配置 main.js knownsec-fed 根目录(不是 src 目录)下面新建 main.js 文件,这个文件和 electron-quick-start 中的官方默认 main.js 几乎一模一样，只修改了加载应用这入口这一个地方：
// 引入electron并创建一个Browserwindow const {app, BrowserWindow} = require(&amp;#39;electron&amp;#39;) const path = require(&amp;#39;path&amp;#39;) const url = require(&amp;#39;url&amp;#39;) // 保持window对象的全局引用,避免JavaScript对象被垃圾回收时,窗口被自动关闭. let mainWindow function createWindow () { //创建浏览器窗口,宽高自定义具体大小你开心就好 mainWindow = new BrowserWindow({width: 800, height: 600}) /* * 加载应用----- electron-quick-start中默认的加载入口 mainWindow.loadURL(url.format({ pathname: path.join(__dirname, &amp;#39;index.html&amp;#39;), protocol: &amp;#39;file:&amp;#39;, slashes: true })) */ // 加载应用----适用于 react 项目  mainWindow.loadURL(&amp;#39;http://localhost:3000/&amp;#39;); // 打开开发者工具，默认不打开  // mainWindow.webContents.openDevTools()  // 关闭window时触发下列事件.  mainWindow.on(&amp;#39;closed&amp;#39;, function () { mainWindow = null }) } // 当 Electron 完成初始化并准备创建浏览器窗口时调用此方法 app.on(&amp;#39;ready&amp;#39;, createWindow) // 所有窗口关闭时退出应用. app.on(&amp;#39;window-all-closed&amp;#39;, function () { // macOS中除非用户按下 `Cmd &#43; Q` 显式退出,否则应用与菜单栏始终处于活动状态.  if (process.platform !== &amp;#39;darwin&amp;#39;) { app.quit() } }) app.on(&amp;#39;activate&amp;#39;, function () { // macOS中点击Dock图标时没有已打开的其余应用窗口时,则通常在应用中重建一个窗口  if (mainWindow === null) { createWindow() } }) // 你可以在这个脚本中续写或者使用require引入独立的js文件.  配置 package.json { &amp;#34;name&amp;#34;: &amp;#34;knownsec-fed&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;0.1.0&amp;#34;, &amp;#34;private&amp;#34;: true, &amp;#34;main&amp;#34;: &amp;#34;main.js&amp;#34;, // 配置启动文件  &amp;#34;homepage&amp;#34;:&amp;#34;.&amp;#34;, //  &amp;#34;dependencies&amp;#34;: { &amp;#34;electron&amp;#34;: &amp;#34;^1.7.10&amp;#34;, &amp;#34;react&amp;#34;: &amp;#34;^16.2.0&amp;#34;, &amp;#34;react-dom&amp;#34;: &amp;#34;^16.2.0&amp;#34;, &amp;#34;react-scripts&amp;#34;: &amp;#34;1.1.0&amp;#34; }, &amp;#34;scripts&amp;#34;: { &amp;#34;start&amp;#34;: &amp;#34;react-scripts start&amp;#34;, &amp;#34;build&amp;#34;: &amp;#34;react-scripts build&amp;#34;, &amp;#34;test&amp;#34;: &amp;#34;react-scripts test --env=jsdom&amp;#34;, &amp;#34;eject&amp;#34;: &amp;#34;react-scripts eject&amp;#34;, &amp;#34;electron-start&amp;#34;: &amp;#34;electron .&amp;#34; // 配置electron的start，区别于web端的start  } }  启动 Electron # 启动react项目 npm start # 启动electron npm run electron-start 支持热调试，当你修改代码后，桌面应用也将会重新更新。
打包 打包 react 项目 首先修改 main.js, 因为现在你要将 react 项目打包在 build 文件夹下面，所以加载应用处改成如下！当然也可在某个配置文件里面配置是否属于开发，此处用if判断一下从未进行选择执行哪段加载应用代码。但是这里为了简便，暂且使用直接修改的方式：
// 加载应用----react 打包 mainWindow.loadURL(url.format({ pathname: path.join(__dirname, &amp;#39;./build/index.html&amp;#39;), protocol: &amp;#39;file:&amp;#39;, slashes: true })) // 加载应用----适用于 react 开发时项目 // mainWindow.loadURL(&amp;#39;http://localhost:3000/&amp;#39;);  默认情况下，homepage 是 http://localhost:3000，build 后，所有资源文件路径都是 /static，而 Electron 调用的入口是 file :协议，/static 就会定位到根目录去，所以找不到静态文件。在 package.json文件中添加 homepage 字段并设置为&amp;rdquo;.&amp;ldquo;后，静态文件的路径就变成了相对路径，就能正确地找到了添加如下配置：
&amp;#34;homepage&amp;#34;:&amp;#34;.&amp;#34;  然后就开始打包 react：
npm run-script build 此时，根目录下面将多出一个build文件夹。
打包 electron 常用打包插件
 electron-builder electron-packager  安装electron-packager
# knownsec-fed目录下安装electron-packager包 npm install electron-packager --save-dev # 安装electron-packager命令 npm install electron-packager -g electron-packager命令介绍
electron-packager &amp;lt;location of project&amp;gt; &amp;lt;name of project&amp;gt; &amp;lt;platform&amp;gt; &amp;lt;architecture&amp;gt; &amp;lt;electron version&amp;gt; &amp;lt;optional options&amp;gt;  location of project: 项目的本地地址，此处我这边是 ~/knownsec-fed location of project: 项目名称，此处是 knownsec-fed platform: 打包成的平台 architecture: 使用 x86 还是 x64 还是两个架构都用 electron version: electron 的版本  于是，根据我这边的情况在 package.json文件的在 scripts 中加上如下代码：
&amp;#34;package&amp;#34;: &amp;#34;electron-packager ~/knownsec-fed/build knownsec-fed --all --out ~/ --electron-version 3.0.10``` **开始打包** ```bash npm run-script package  提醒
由于打包的时候会把浏览器内核完整打包进去，所以就算你的项目开发就几百k的资源，但最终的打包文件估计也会比较大。
其它 此文章未涉及 Electron 具体的技术，只是简单的介绍了一下 react &#43; electron 的一个配置及打包的流程。或许以后会写关于 Electron 的技术细节。Electron 有着非常强大的 api，其背后涉及的技术也非常多。
友情链接
 Electron github
 Electron 英文文档
 Electron 中文手册
 electron-packager github
 基于Electron构建的app
 electron-react-boilerplate github
 </content>
    </entry>
    
     <entry>
        <title>广东人真是太太太太太好玩了</title>
        <url>http://xuzhibin.com/post/2018/guangdongren/</url>
        <categories>
          <category>live</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> </content>
    </entry>
    
     <entry>
        <title>gogs开启ssh支持</title>
        <url>http://xuzhibin.com/post/2018/gogs-ssh/</url>
        <categories>
          <category>server</category>
        </categories>
        <tags>
          <tag>gogs</tag>
        </tags>
        <content type="html"> 已经通过docker安装了gogs，http能正常使用，ssh不能使用
gogs配置app.ini [server] DOMAIN = xxx HTTP_PORT = 3000 ROOT_URL = http://xxx:13000/ DISABLE_SSH = false SSH_DOMAIN = xxx:10022 SSH_PORT = 22 START_SSH_SERVER = false SSH_LISTEN_PORT = 10033 SSH_ROOT_PATH = /home/git/.ssh OFFLINE_MODE = false REWRITE_AUTHORIZED_KEYS_AT_START = false docker ssh的配置文件路径 /app/gogs/docker/sshd_config 通过下面命令可以获得
ps aux 设置目录权限 chmod 0777 /data/git/.ssh chmod 0600 /data/git/.ssh/authorized_keys 在后台/管理面板执行 重新生成 &amp;lsquo;.ssh/authorized_keys&amp;rsquo; 文件（警告：不是 Gogs 的密钥也会被删除）
重启ssh服务 $ service ssh restart $ exit 重新登录 ssh -p 10022 git@xxx git clone格式 ssh://git@xxx:10022/jabin/myproject.git copy ssh-key pbcopy &amp;lt; ~/.ssh/id_rsa.pub</content>
    </entry>
    
     <entry>
        <title>mac下安装pyside2</title>
        <url>http://xuzhibin.com/post/2018/mac-pyside-1st/</url>
        <categories>
          <category>python</category>
        </categories>
        <tags>
          <tag>pyside</tag>
        </tags>
        <content type="html"> 环境：mac已经安装了python3.5，pip3.5 IDE:PyCharm
安装pyside2 pip3.5 install --index-url=http://download.qt.io/snapshots/ci/pyside/5.9/latest/ pyside2 --trusted-host download.qt.io 简单实例 #!/usr/bin/python # -*- coding: utf-8 -*- # 1st.py import sys from PySide2 import QtGui from PySide2 import QtWidgets app = QtWidgets.QApplication(sys.argv) wid = QtWidgets.QWidget() wid.resize(250, 150) wid.setWindowTitle(&amp;#39;Simple&amp;#39;) wid.show() sys.exit(app.exec_()) 面向对象写法 #!/usr/bin/python # -*- coding: utf-8 -*- import sys from PySide2 import QtGui from PySide2 import QtWidgets class Example(QtWidgets.QWidget): def __init__(self): super(Example, self).__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&amp;#39;Icon&amp;#39;) self.setWindowIcon(QtGui.QIcon(&amp;#39;icon.png&amp;#39;)) self.show() def main(): app = QtWidgets.QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) if __name__ == &amp;#39;__main__&amp;#39;: main()</content>
    </entry>
    
     <entry>
        <title>家庭数据中心</title>
        <url>http://xuzhibin.com/post/2018/nas-home/</url>
        <categories>
          <category>tools</category>
        </categories>
        <tags>
          <tag>群晖</tag>
        </tags>
        <content type="html"> 私人数据越来越多（如照片），网盘越来越小，并且不是关闭就是被墙。决定搭建自己的家庭数据中心。 计划&amp;amp;预算  硬件：群晖218&#43;（加一条8g内存），希捷酷狼4T*2，玩客云，希捷移动硬盘2T（玩客云用），4T（群晖用）各一个，小米盒子国际版，斐讯k2p路由器（刷官改rom） 预算：8k 目的：数据备份，家庭影视 其实黑群也可以，价格更便宜。最好4盘位，2盘位还是少了点。  家庭网络改造 通过 搬瓦工 安装ss，并在k2p设置ss服务和frp服务 - 可以无缝访问google - 小米盒子（原生android tv）可以访问youtube - 家庭网络设备可以通过frp对外访问
群晖外网访问 全球访问，frp速度更快，并且黑群也能用 - quickconnect - frp
数据备份（多种备份方式，稳如磐石） Drive 多平台同步数据
DS Photo、Moments 多平台同步照片
Cloud Sync  同步下载百度网盘资源 同步下载Dropbox资源 将照片同步上传一份至onedrive和腾讯云cos（免费额度50G），即使本地硬盘挂了，也有网络备份  Hyper Backup  定期将Drive数据和photo数据备份至移动硬盘。  快照  重要文件定期快照，随时恢复  家庭影视  玩客云负责下载电影（24小时下载电影） 手动通过smb将玩客云下载的电影移动到群晖的移动硬盘（群晖空间不大，只有4T，影视资源存至移动硬盘） 手机安装ds vedio、vlc；电视安装kodi、vlc； kodi通过局域网共享方式，可以将群晖的影视目录，照片目录，音乐目录，玩客云的影视目录加载进来，以后开机就可以直接看； 电视可以用VLC播放局域网视频资源 手机可以通过ds vedio直接看（外网也能访问），局域网可以vlc  家庭照片  手机可以用ds photo，Monents同步上传照片，也可以全球查看。 电视可以通过kodi查看  web station 部署web服务，默认安装的php缺少很多模块，基本上当作静态站点使用（静态blog可以使用hexo，也可以使用MWeb生成）
Docker 服务扩展 迅雷远程下载 可以通过迅雷远程下载文件。
lnmp 可以部署运行php程序。
gogs 部署git服务，sqlite数据库，部署方便，占资源少。
Virtual Machine Manager 安装虚拟机，装了一个windows 2016，群晖需要8G内存以上才能安装。
Antivirus Essential 之前中过毒，安装一个毒软定期检查
Active Backup for Server 自动备份服务器文件，Linux需要安装rsync服务，windows只能备份局域网的smb
硬盘扩展 利用iSCSI扩展局域网windows硬盘空间，对于win系统非常好用。
Time Machine 备份mac系统必备，比买apple服务便宜很多。
断电保护 准备买个bk650，暂时资金不够，而且很少断电，还没买。
</content>
    </entry>
    
     <entry>
        <title>在Coding部署Hexo</title>
        <url>http://xuzhibin.com/post/2016/hexo-coding/</url>
        <categories>
          <category>tools</category>
        </categories>
        <tags>
          <tag>hexo</tag>
        </tags>
        <content type="html">  网上的Hexo教程大多是部署在Github，在实际的使用中，Github速度比较满，有时更新还会抽风一下，于是想在国内找个替代方案。
目前来说，Coding从体验和速度来说，都是国内比较好的选择，阿里云虽然也有代码库，但是刚开始起步，很多都还不完善，但是如果做下去，未来看好。
下面以Coding为例，说一下部署的步骤。
注册 这个就不多说了，常规按步骤注册即可。传送门
创建项目  我们要创建的是 用户Pages，项目名需要和用户名一样，这样我们就可以用{user_name}.coding.me 形式的 URL 直接访问，适合用作个人或组织的演示网站。
 在新建项目里创建一个 coding-pages 分支，Coding默认是用 coding-pages 分支作为Pages的文件库。
 开启项目的Pages服务。
  Hexo配置 在Coding，我使用 coding-pages 分支发布Hexo，master 分支备份存储源文件。
备份Hexo我是用的插件是 hexo-git-backup
下面是我的配置文件，我是同时使用了Github和Coding服务，也可以只使用其中一个。
# 发布 deploy: - type: git repo: github: git@github.com:xuzhibin/xuzhibin.github.io.git,master coding: git@git.coding.net:xuzhibin/xuzhibin.git,coding-pages # 备份 backup: type: git repository: coding: git@git.coding.net:xuzhibin/xuzhibin-backup.git,master github: git@github.com:xuzhibin/hexo-blog-backup.git,master 发布 &amp;amp; 备份 发布
hexo d 备份
hexo b 预览 Github: xuzhibin.github.io
Coding: xuzhibin.coding.me
Coding注册链接
其他  域名绑定,在Coding的Pages标签页，是有域名绑定功能的，我目前的Hexo是用rsync方式发布在阿里云，所以没有具体测试。
 Coding可以直接在仓库页打标签（Github没有这个功能），方便以后有需要时可以回滚。
 Coding的Pages服务有几分钟的更新延迟。
  </content>
    </entry>
    
     <entry>
        <title>Hexo安装记</title>
        <url>http://xuzhibin.com/post/2016/hexo-install/</url>
        <categories>
          <category>tools</category>
        </categories>
        <tags>
          <tag>hexo</tag>
        </tags>
        <content type="html">  Hexo是啥 Hexo 是由 Node.js 驱动的一款快速、简单且功能强大的博客框架。可以快速将 Markdown 格式的文档生成静态页面。是越来越笨重的 Wordpress 和麻烦的空间管理的替代方案。
安装 Hexo 首先翻看一遍 Hexo 官方文档
环境准备 安装 Node.js &amp;amp; Git
该命令执行后，自动装好node和npm。
brew install node 配置 Git 按照Github提示，创建SSH秘钥：
$ mkdir ~/.ssh #创建ssh命令 $ cd ~/.ssh $ ssh-keygen -t rsa -C &amp;#34;your_email@example.com&amp;#34; #注意更改Email地址 $ pbcopy &amp;lt; ~/.ssh/id_rsa.pub 此时，pdcopy命令已经将id_rsa.pub内容复制到剪切板。
登录 github：https://github.com/settings/ssh 点击Add an SSH Key，Title 部分填写一个所用电脑的名称，然后在Key部分填写之前通过pdcopy命令复制的内容。生成 key https://help.github.com/articles/generating-ssh-keys/
$ git config --global user.name &amp;#34;yourusername&amp;#34; $ git config --global user.email &amp;#34;youremail&amp;#34; 测试 可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：
$ ssh -T git@github.com 如果是下面的反馈：
The authenticity of host &amp;#39;github.com (207.97.227.239)&amp;#39; can&amp;#39;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 不要紧张，输入yes就好，然后会看到：
Hi cnfeat! You&amp;#39;ve successfully authenticated, but GitHub does not provide shell access. 安装 Hexo $ npm install -g hexo-cli 好了，这个时候如果报错，记得加 sudo
$ sudo npm install -g hexo-cli 配置 Hexo 进入想要存放博客的文件夹，初始化设置：
$ hexo init $ npm install 初始化成功后，文件夹里会有这些东西：
. ├── _config.yml #配置文件 ├── package.json #应用程序数据 ├── scaffolds ├── source #网站内容 | ├── _drafts #草稿 | └── _posts #文章 └── themes #主题 配置文件的详细说明请查看官方文档。
本地访问博客 生成静态文件：
$ hexo generate 启动本地服务：
$ hexo server 这时提示
Hexo is running at http://0.0.0.0:4000/. Press Ctrl&#43;C to stop. 然后在浏览器打开 http://0.0.0.0:4000/，就可以看到迁移好的博客啦！
挑选主题 可参考 有那些好看的 Hexo 主题？
下载主题：
git clone https://github.com/xxxx themes/xxx$ cd your-hexo-site $ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题：克隆/下载 完成后，打开 站点配置文件 “_config.yml”，找到 theme 字段，并将其值更改为下载的主题名字。
剩下的就根据主题使用文档，按照自己的喜好修改了。
我选的 NEXT主题 胜在 说明文档 超详细的~
安装插件 站内搜索 hexo-generator-search插件为 Hexo3 提供搜索功能。
安装：
$ npm install hexo-generator-search --save Feed hexo-generator-feed 可以生成Atom 1.0 或 RSS 2.0 feed。
安装：
$ npm install hexo-generator-feed --save Sitemap 说明
安装：
$ npm install hexo-generator-seo-friendly-sitemap --save 配置 Github 并上传 新建跟用户名同名的 repository，以“.github.io” 为后缀
创建成功后，点击界面右侧的Settings，打开页面后找到GitHub Pages，点击Launch automatic page generator，生成 page。
然后在网站配置文件 _config.yml文件中，找到Deployment，修改配置：
deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 如果使用 git 方式部署，执行
npm install hexo-deployer-git --save 命令来安装插件。
安装成功后，在当前目录进行 deploy 操作
hexo d 上传成功后，访问 yourname.github.io ，测试是否可以正常访问。
绑定域名 在 Github 里生成 CNAME 文件 为了绑定域名，首先在 Hexo 的 &amp;ldquo;source&amp;rdquo; 文件夹中新建一个CNAME文件（没有后缀），文件内容为你要设置的域名。目的是将你的域名（如 uegeek.com ）指向 Github 服务器。
Deploy 到 Github上去后大概需要几分钟生效。
到 DNSPod 新建域名，并添加 CNAME 记录指向 kidult00.github.io 。
当打开 uegeek.com 看到改头换面的博客后，内心默默地原谅自己拖延了两年 T.T
Hexo设置 站点设置 # Hexo Configuration ## Docs: http://hexo.io/docs/configuration.html ## Source: https://github.com/tommy351/hexo/ # Site #整站的基本信息 title: 1000 words a Day #网站标题 subtitle: Writing 1000 Words a Day Changes My Life #网站副标题 description: 学习总结 思考感悟 知识管理 #网站描述 author: cnFeat #网站作者，在下方显示 email: cnFeat@gmail.com #联系邮箱 language: zh-CN # URL ## If your site is put in a subdirectory url: http://www.cnfeat.com #你的域名 root: / permalink: :year/:month/:day/:title/ tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code # Directory source_dir: source public_dir: public # Writing new_post_name: :title.md # File name of new posts default_layout: post auto_spacing: false # Add spaces between asian characters and western characters titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab max_open_file: 100 multi_thread: true filename_case: 0 render_drafts: false post_asset_folder: false highlight: enable: true line_number: true tab_replace: # Category &amp;amp; Tag default_category: uncategorized category_map: tag_map: # Archives ## 2: Enable pagination ## 1: Disable pagination ## 0: Fully Disable archive: 2 category: 2 tag: 2 # Server ## Hexo uses Connect as a server ## You can customize the logger format as defined in ## http://www.senchalabs.org/connect/logger.html port: 4000 server_ip: 0.0.0.0 logger: false logger_format: # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: H:mm:ss # Pagination ## Set per_page to 0 to disable pagination per_page: 15 #每页15篇文章 pagination_dir: page # Disqus #社会化评论disqus，我使用多说，在主题中配置 disqus_shortname: # Extensions ## Plugins: https://github.com/tommy351/hexo/wiki/Plugins ## Themes: https://github.com/tommy351/hexo/wiki/Themes theme: jacman exclude_generator: Plugins: - hexo-generator-feed - hexo-generator-sitemap #sitemap sitemap: path: sitemap.xml #Feed Atom feed: type: atom path: atom.xml limit: 20 # Markdown ## https://github.com/chjj/marked markdown: gfm: true pedantic: false sanitize: false tables: true breaks: true smartLists: true smartypants: true # Stylus stylus: compress: false # Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: github repository: https://github.com/xuzhibin/xuzhibin.github.io.git branch: master 模版设置 . ├── languages #多语言 | ├── default.yml#默认语言 | └── zh-CN.yml #中文语言 ├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制 | ├── _partial #局部的布局，此目录下的*.ejs是对头尾等局部的控制 | └── _widget#小挂件的布局，页面下方小挂件的控制 ├── source #源码 | ├── css#css源码 | | ├── _base #*.styl基础css | | ├── _partial #*.styl局部css | | ├── fonts #字体 | | ├── images #图片 | | └── style.styl #*.styl引入需要的css源码 | ├── fancybox #fancybox效果源码 | └── js #javascript源代码 ├── _config.yml#主题配置文件 └── README.md #用GitHub的都知道 常用命令 发表新文章 $ hexo n #写文章 其中my new post为文章标题，执行命令后，会在项目\source_posts中生成my new post.md文件，用编辑器打开编写即可。
当然，也可以直接在\source_posts中新建一个md文件，我就是这么做的。
写完后，推送到服务器上，执行
$ hexo g #生成 $ hexo d #部署 # 可与hexo g合并为 hexo d -g 用Hexo发表文章的Markdown语法 title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中 date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改 categories: example #分类 tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格 description: 附加一段文章摘要，字数最好在140字以内。 --- 以下正文 常用命令 hexo new &amp;#34;postName&amp;#34; #新建文章 hexo new page &amp;#34;pageName&amp;#34; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&amp;#39;ctrl &#43; c&amp;#39;关闭server） hexo deploy #将.deploy目录部署到GitHub 常用复合命令 hexo d -g #生成加部署 hexo s -g #预览加部署 简写 hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy Hexo备份 已有人写了插件，hexo-git-backup，按步骤操作即可；
$ npm install hexo-git-backup --save 修改站点配置文件 _config.yml.
backup: type: git repository: github: git@github.com:xxx/xxx.git,branchName gitcafe: git@github.com:xxx/xxx.git,branchName 使用
hexo backup or
hexo b Hexo部署在VPS $ npm install hexo-deployer-rsync --save 根据 Hexo rsync 部署文档 在 Hexo 中的 _config.yml 中添加 Deploy 的配置，以下是我在自己项目中的配置代码
deploy: type: rsync host: 你 VPS 的 IP 地址或者域名 user: root root: 你想将 Hexo 生成的静态文件存放在 VPS 中的目录 例如: /www/hexo/blog/ port: 你 VPS 的 ssh 端口号 delete: true verbose: true ignore_errors: false *必须先在 VPS 上创建好了想要存放 Hexo 静态文件的目录， rsync 不能创建不存在的目录
我看网上有的朋友说光在 Hexo 中使用 rsync 不够，在 VPS 也需要下载 rsync 服务，但是我在阿里云上就没有下载 rsync 服务。如果你在 Hexo 中用 rsync 部署的时候一直报错，那就在 VPS 上下载 rsync 服务，看能否解决一直出错的原因，命令如下
$ yum -y install rsync 如果rsync 报下面的错误
rsync error: some files could not be transferred (code 23) at main.c(702) 解决方法: rsync的source有些文件没有读权限，所以报错。
chmod &#43;r ./* -R 再次同步，即可OK.
相关链接 如何搭建一个独立博客——简明Github Pages与Hexo教程
</content>
    </entry>
    
     <entry>
        <title>npm小结</title>
        <url>http://xuzhibin.com/post/2016/npm-summary/</url>
        <categories>
          <category>tools</category>
        </categories>
        <tags>
          <tag>npm</tag>
        </tags>
        <content type="html">  随着一系列基于nodes的应用/工具的出现，无论在node应用的开发，还是使用中，包管理都扮演着一个很重要的作用。NPM（node package manager），作为node的包管理工具，极大地便利了我们的开发工作，很有必要了解一下。
NPM是什么 NPM（node package manager），通常称为node包管理器。顾名思义，它的主要功能就是管理node包，包括：安装、卸载、更新、查看、搜索、发布等。 npm的背后，是基于couchdb的一个数据库，详细记录了每个包的信息，包括作者、版本、依赖、授权信息等。它的一个很重要的作用就是：将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。
npm官网：https://npmjs.org/
npm官方文档：https://npmjs.org/doc/README.html
我们需要了解什么  npm的安装、卸载、升级、配置 npm的使用：package的安装、卸载、升级、查看、搜索、发布 npm包的安装模式：本地 vs 全局 package.json：包描述信息 package版本：常见版本声明形式  npm的安装 Mac 该命令执行后，自动装好node和npm。
brew install node npm包安装模式 在具体介绍npm包的管理之前，我们首先得来了解一下npm包的两种安装模式。
本地安装 vs 全局安装（重要） node包的安装分两种：本地安装、全局安装。两者的区别如下，后面会通过简单例子说明 本地安装：package会被下载到当前所在目录，也只能在当前目录下使用。 全局安装：package会被下载到到特定的系统目录下，安装的package能够在所有目录下使用。
npm install pkg – 本地安装 运行如下命令，就会在当前目录下安装grunt-cli（grunt命令行工具）
npm install grunt-cli 安装结束后，当前目录下回多出一个node_modules目录，grunt-cli就安装在里面。同时注意控制台输出的信息：
grunt-cli@0.1.9 node_modules/grunt-cli ├── resolve@0.3.1 ├── nopt@1.0.10 (abbrev@1.0.4) └── findup-sync@0.1.2 (lodash@1.0.1, glob@3.1.21) 简单说明一下：
 grunt-cli@0.1.9：当前安装的package为grunt-cli，版本为0.19 node_modules/grunt-cli：安装目录 resolve@0.3.1：依赖的包有resolve、nopt、findup-sync，它们各自的版本、依赖在后面的括号里列出来  npm install -g pkg- 全局安装 上面已经安装了grunt-cli，然后你跑到其他目录下面运行如下命令
grunt 果断提示你grunt命令不存在，为什么呢？因为上面只是进行了本地安装，grunt命令只能在对应安装目录下使用。
-bash: grunt: command not found 如果为了使用grunt命令，每到一个目录下都得重新安装一次，那不抓狂才怪。肿么办呢？ 很简单，采用全局安装就行了，很简单，加上参数-g就可以了
npm install -g grunt-cli 于是，在所有目录下都可以无压力使用grunt命令了。这个时候，你会注意到控制台输入的信息有点不同。主要的区别在于安装目录，现在变成了/usr/local/lib/node_modules/grunt-cli，/usr/local/lib/node_modules/也就是之前所说的全局安装目录啦。
grunt-cli@0.1.9 /usr/local/lib/node_modules/grunt-cli ├── resolve@0.3.1 ├── nopt@1.0.10 (abbrev@1.0.4) └── findup-sync@0.1.2 (lodash@1.0.1, glob@3.1.21) npm包管理 npm的包管理命令是使用频率最高的，所以也是我们需要牢牢记住并熟练使用的。其实无非也就是几个动作：安装、卸载、更新、查看、搜索、发布等。
安装最新版本的grunt-cli
npm install grunt-cli 安装0.1.9版本的grunt-cli
npm install grunt-cli@&amp;#34;0.1.9&amp;#34; 通过package.json进行安装
如果我们的项目依赖了很多package，一个一个地安装那将是个体力活。我们可以将项目依赖的包都在package.json这个文件里声明，然后一行命令搞定
nam install 其他package安装命令 运行如下命令，列出所有npm install可能的参数形式
npm install --help 输出如下，有兴趣的童鞋可以了解下
npm install &amp;lt;tarball file&amp;gt; npm install &amp;lt;tarball url&amp;gt; npm install &amp;lt;folder&amp;gt; npm install &amp;lt;pkg&amp;gt; npm install &amp;lt;pkg&amp;gt;@&amp;lt;tag&amp;gt; npm install &amp;lt;pkg&amp;gt;@&amp;lt;version&amp;gt; npm install &amp;lt;pkg&amp;gt;@&amp;lt;version range&amp;gt; 卸载grunt-cli 比如卸载grunt-cli
npm uninstall grunt-cli 卸载0.1.9版本的grunt-cli
npm uninstall grunt-cli@&amp;#34;0.1.9&amp;#34; npm ls：查看安装了哪些包
运行如下命令，就可以查看当前目录安装了哪些package
npm ls 输出如下
/private/tmp/npm └─┬ grunt-cli@0.1.9 ├─┬ findup-sync@0.1.2 │ ├─┬ glob@3.1.21 │ │ ├── graceful-fs@1.2.3 │ │ ├── inherits@1.0.0 │ │ └─┬ minimatch@0.2.12 │ │ ├── lru-cache@2.3.0 │ │ └── sigmund@1.0.0 │ └── lodash@1.0.1 ├─┬ nopt@1.0.10 │ └── abbrev@1.0.4 └── resolve@0.3.1 输出如下，同样，如果是要查看package的全局安装信息，加上-g就可以
npm ls pkg：查看特定package的信息 运行如下命令，输出grunt-cli的信息
npm ls grunt-cli 输出的信息比较有限，只有安装目录、版本，如下：
/private/tmp/npm └── grunt-cli@0.1.9 如果要查看更详细信息，可以通过npm info pkg，输出的信息非常详尽，包括作者、版本、依赖等。
npm info grunt-cli npm update pkg：package更新
npm update grunt-cli npm search pgk：搜索 输入如下命令
npm search grunt-cli 返回结果如下
npm http GET http://registry.npmjs.org/-/all/since?stale=update_after&amp;amp;startkey=1375519407838 npm http 200 http://registry.npmjs.org/-/all/since?stale=update_after&amp;amp;startkey=1375519407838 NAME DESCRIPTION AUTHOR DATE KEYWORDS grunt-cli The grunt command line interface. =cowboy =tkellen 2013-07-27 02:24 grunt-cli-dev-exitprocess The grunt command line interface. =dnevnik 2013-03-11 16:19 grunt-client-compiler Grunt wrapper for client-compiler. =rubenv 2013-03-26 09:15 gruntplugin grunt-clientside Generate clientside js code from CommonJS modules =jga 2012-11-07 01:20 gruntplugin npm发布 这个命令我自己也还没实际用过，不误导大家，语法如下，也可参考官方对于package发布的说明 https://npmjs.org/doc/developers.html：
npm publish &amp;lt;tarball&amp;gt; npm publish &amp;lt;folder&amp;gt; NPM配置 npm的配置工作主要是通过npm config命令，主要包含增、删、改、查几个步骤，下面就以最为常用的proxy配置为例。
设置proxy 内网使用npm很头痛的一个问题就是代理，假设我们的代理是 http://proxy.example.com:8080，那么命令如下：
npm config set proxy http://proxy.example.com:8080 由于npm config set命令比较常用，于是可以如下简写
npm set proxy http://proxy.example.com:8080 查看proxy 设置完，我们查看下当前代理设置
npm config get proxy 输出如下：
http://proxy.example.com:8080/ 同样可如下简写：
npm get proxy 删除proxy 代理不需要用到了，那删了吧
npm delete proxy 查看所有配置 npm config list 直接修改配置文件 有时候觉得一条配置一条配置地修改有些麻烦，就直接进配置文件修改了
npm config edit 关于package.json 这货在官网似乎没有详细的描述，其实就是包的描述信息啦。假设当我们下载了node应用，这个node应用依赖于A、B、C三个包，如果没有package.json，我们需要人肉安装这个三个包（如果对版本有特定要求就更悲剧了）：
npm install A npm install B npm install C 有了package.json，一行命令安装所有依赖。
npm install package.json的生成 npm init package.json字段简介 字段相当多，但最重要的的是下面几个
 name: package的名字（由于他会成为url的一部分，所以 non-url-safe 的字母不会通过，也不允许出现”.”、”_”），最好先在http://registry.npmjs.org/上搜下你取的名字是否已经存在
version: package的版本，当package发生变化时，version也应该跟着一起变化，同时，你声明的版本需要通过semver的校验（semver可自行谷歌） dependencies: package的应用依赖模块，即别人要使用这个package，至少需要安装哪些东东。应用依赖模块会安装到当前模块的node_modules目录下。
devDependencies：package的开发依赖模块，即别人要在这个package上进行开发
其他：参见官网
 package版本 在package.json里，你经常会在包名后看到类似”~0.1.0″这样的字符串，这就是包的版本啦。下面会列举最常见的版本声明形式，以及版本书写的要求： 常见版本声明形式 a、”~1.2.3″ 是神马意思呢，看下面领悟
&amp;#34;~1.2.3&amp;#34; = &amp;#34;&amp;gt;=1.2.3 &amp;amp;lt;1.3.0&amp;#34; &amp;#34;~1.2&amp;#34; = &amp;#34;&amp;gt;=1.2.0 &amp;amp;lt;1.3.0&amp;#34; &amp;#34;~1&amp;#34; = &amp;#34;&amp;gt;=1.0.0 &amp;amp;lt;1.1.0&amp;#34; b、”1.x.x”是什么意思呢，继续自行领悟
&amp;#34;1.2.x&amp;#34; = &amp;#34;&amp;gt;=1.2.0 &amp;amp;lt;1.3.0&amp;#34; &amp;#34;1.x.x&amp;#34; = &amp;#34;&amp;gt;=1.0.0 &amp;amp;lt;2.0.0&amp;#34; &amp;#34;1.2&amp;#34; = &amp;#34;1.2.x&amp;#34; &amp;#34;1.x&amp;#34; = &amp;#34;1.x.x&amp;#34; &amp;#34;1&amp;#34; = &amp;#34;1.x.x&amp;#34; 版本书写要求 1. 版本可以v开头，比如 v1.0.1（v只是可选） 2. 1.0.1-7，这里的7是所谓的“构建版本号”，不理是神马，反正版本大于1.0.1 3. 1.0.1beta，或者1.0.1-beta，如果1.0.1后面不是 “连字符加数字” 这种形式，那么它是pre release 版本，即版本小于 1.0.1 4. 根据b、c，有：0.1.2-7 &amp;gt; 0.1.2-7-beta &amp;gt; 0.1.2-6 &amp;gt; 0.1.2 &amp;gt; 0.1.2beta
写在后面 内容只是简单地把最常见的命令，以及一些需要了解的内容列了出来。如要进一步了解，可参考官网说明。此外，npm help是我们最好的朋友，如果忘了有哪些命令，命令下有哪些参数，可通过help进行查看。
</content>
    </entry>
    
     <entry>
        <title>Git 常用命令速查表</title>
        <url>http://xuzhibin.com/post/2013/git-command/</url>
        <categories>
          <category>tools</category>
        </categories>
        <tags>
          <tag>git</tag>
        </tags>
        <content type="html">  配置 $ git config --global user.name &amp;#34;John Doe&amp;#34; $ git config --global user.email johndoe@example.com 创建版本库 $ git clone [url] #克隆远程版本库 $ git clone git://github.com/schacon/grit.git $ git clone git://github.com/schacon/grit.git mygrit $ git clone --bare my_project my_project.git #创建纯仓库 $ git init #初始化本地版本库 $ git init --bare #创建纯仓库 修改和提交 $ git status #查看状态 $ git diff #查看变更内容 $ git diff --cached #查看已经暂存起来的文件和上次提交时的快照之间的差异 $ git diff master...contrib #特性分支contrib和它同master分支的共同祖先之间的差异（合并时实际将要引入的新代码） $ git add . #跟踪所有改动过的文件 $ git add [file] #跟踪指定的文件 $ git mv [old] [new] #文件改名 $ git rm [file] #删除文件 $ git rm --cached [file] #停止跟踪文件但不删除 $ git commit -m &amp;#34;commit message&amp;#34; #提交所有更新过的文件 $ git commit --amend #修改最后一次提交 $ git commit -a -m &amp;#39;added new benchmarks&amp;#39; #跳过暂存区域直接提交 查看提交历史 $ git log #查看提交历史 $ git log --pretty=oneline $ git log -p [file] #查看指定文件的提交历史 $ git log master..experiemnt #所有可从experiment分支中获得而不能从master分支中获得的提交 $ git blame [file] #以列表方式查看指定文件的提交历史 $ git log origin/featureA ^featureA #比较origin/featureA及featureA分支，查看origin/featureA更新了哪些内容 撤消 $ git reset --hard HEAD #撤消工作目录中所有未提交文件的修改内容 $ git reset --hard [commit] #会退到某个[commit] $ git reset HEAD [file] #取消已经暂存的文件 $ git checkout HEAD [file] #撤消指定的未提交文件的修改内容[已暂存] $ git checkout -- benchmarks.rb #取消对文件的修改[未暂存] $ git revert [commit] #撤消指定的提交 分支与标签 $ git branch #显示所有本地分支 $ git checkout [branch/tag] #切换到指定分支或标签 $ git checkout -b featureB origin/master #从分支origin/master克隆并创建分支featureB，切换至featureB $ git branch [new-branch] #创建新分支 $ git branch sc/ruby_client master #从master分支克隆一个sc/ruby_client分支 $ git branch -d [branch] #删除本地分支 $ git branch --merged #查看哪些分支已被并入当前分支 $ git branch --no-merged #查看哪些分支未被并入当前分支 $ git tag #列出所有本地标签 $ git tag [tagname] #基于最新提交创建标签 $ git tag -d [tagname] #删除标签 合并与衍合 $ git merge [branch] #合并指定分支到当前分支 $ git rebase [branch] #衍合指定分支到当前分支 远程操作 $ git remote -v #查看远程版本库信息 $ git remote show [remote] #查看指定远程版本库信息 $ git remote add [remote] [url] #添加远程版本库 $ git remote rename [old-remote-name] [new-remote-name] #远程仓库的重命名 $ git remote rm [remote] #远程仓库的删除 $ git fetch [remote] #从远程库获取代码 $ git pull [remote] [branch] #下载代码及快速合并至当前分支 $ git push [remote] [branch] #上传代码及快速合并 $ git push origin featureB[本地分支]:featureBee[远程分支] #推送本地分支至指定的远程分支 $ git push [remote] :[branch/tag-name] #删除远程分支或标签 $ git push --tags #上传所有标签 其他 $ git describe master #生成内部版本号 $ git archive master --prefix=&amp;#39;project/&amp;#39; | gzip &amp;gt; &amp;#39;git describe master&amp;#39;.tar.gz #打包成tar $ git archive master --prefix=&amp;#39;project/&amp;#39; --format=zip &amp;gt; &amp;#39;git describe master&amp;#39;.zip #打包成zip $ git stash #储藏 $ git stash list #查看储藏列表 $ git stash apply stash@2 #应用名为stash@2 的储藏。如果你不指明，Git 默认使用最近的储藏并尝试应用它 $ git stash drop stash@{0} #移除名为stash@{0}的储藏 $ git blame -L 12,22 simplegit.rb #文件标注 Git文件 .gitattributes #属性文件
.doc diff=word database.xml merge=ours .gitignore #忽略某些文件
# 此为注释– 将被Git忽略 *.[oa] # 忽略所有.o或.a结尾的文件 !lib.a # 但lib.a 除外 /TODO # 仅仅忽略项目根目录下的TODO文件，不包括subdir/TODO build/ # 忽略build/目录下的所有文件 doc/*.txt # 会忽略doc/notes.txt但不包括doc/server/arch.txt</content>
    </entry>
    
     <entry>
        <title>Linux下重置MySQL root密码</title>
        <url>http://xuzhibin.com/post/2013/reset-mysql-rootpass/</url>
        <categories>
          <category>server</category>
        </categories>
        <tags>
          <tag>mysql</tag>
        </tags>
        <content type="html"> 1、停止MySQL服务 执行：
/etc/init.d/mysql stop 你的机器上也不一定是/etc/init.d/mysql，也可能是/etc/init.d/mysqld
2、跳过验证启动MySQL
/usr/local/mysql/bin/mysqld_safe --skip-grant-tables &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp; 注：如果mysqld_safe的位置如果和上面不一样需要修改成你的，如果不清楚可以用find命令查找。
3、重置密码 等一会儿，然后执行：
/usr/local/mysql/bin/mysql -u root mysql 出现mysql提示符后输入：
update user set password = Password(&amp;#39;要设置的密码&amp;#39;) where User = &amp;#39;root&amp;#39;; 回车后执行：
flush privileges; 刷新MySQL系统权限相关的表。再执行：
exit; 退出。
4、重启MySQL 杀死MySQL进程：
killall mysqld 重启MySQL：
/etc/init.d/mysql start</content>
    </entry>
    
     <entry>
        <title>VPS硬盘被撑满</title>
        <url>http://xuzhibin.com/post/2013/vps-harddisk-full/</url>
        <categories>
          <category>server</category>
        </categories>
        <tags>
          <tag>vps</tag><tag>w3tc</tag>
        </tags>
        <content type="html"> 早上打开博客，发现显示“无法连上数据库”，遂登录ssh，重启服务。重启后，Wordpress可以访问了，但是标签及分类目录全部丢失。一阵Google，百度后，大多说是缓存爆满导致。
df -lh 果然，硬盘空间全部满了。于是寻找是哪个目录的问题。
 先du -sh /*, 在/home目录的地方卡住了，然后Ctrl&#43;C, 然后  ll|grep -v &amp;#34;total&amp;#34;|grep -v &amp;#34;home&amp;#34;|awk &amp;#39;{print $9}&amp;#39;|xargs du -sh  发现其他目录不大，知道是/home目录的问题了 递归对/home目录使用上面的方法处理  最后，发现是wordpress目录下的 wp-content/cache/* 超过10G了，此目录是 W3 Total Cache插件 的缓存目录，清空以下目录：
wp-content/cache/object/*
wp-content/cache/db/*
wp-content/cache/page/*
wp-content/cache/tmp/*
重启服务，OK。
此文给使用W3TC插件的同学一个提醒。
</content>
    </entry>
    
     <entry>
        <title>android中加载图片时出现oom</title>
        <url>http://xuzhibin.com/post/2013/android-oom/</url>
        <categories>
          <category>android</category>
        </categories>
        <tags>
          <tag>android</tag>
        </tags>
        <content type="html"> ImageView加载图片时，有时会出现OOM
imageView.setImageResource(imageId); 解决方法
/** * 以最省内存的方式读取本地资源的图片 * * @param context * @param resId * @return */ public static Bitmap readBitMap(Context context, int resId) { BitmapFactory.Options opt = new BitmapFactory.Options(); opt.inPreferredConfig = Bitmap.Config.RGB_565; opt.inPurgeable = true; opt.inInputShareable = true; // 获取资源图片  InputStream is = context.getResources().openRawResource(resId); return BitmapFactory.decodeStream(is, null, opt); }Bitmap bitmap=readBitMap(LoginActivity.this,imageId); imageView.setImageBitmap(bitmap); 那是为什么，会导致oom呢：
　原来当使用像 imageView.setBackgroundResource，imageView.setImageResource, 或者 BitmapFactory.decodeResource 这样的方法来设置一张大图片的时候，这些函数在完成decode后，最终都是通过java层的createBitmap来完成的，需要消耗更多内存。
　因此，改用先通过BitmapFactory.decodeStream方法，创建出一个bitmap，再将其设为ImageView的 source，decodeStream最大的秘密在于其直接调用JNI&amp;gt;&amp;gt;nativeDecodeAsset()来完成decode，无需再使用java层的createBitmap，从而节省了java层的空间。如果在读取时加上图片的Config参数，可以跟有效减少加载的内存，从而跟有效阻止抛out of Memory异常。
　另外，需要特别注意：
　decodeStream是直接读取图片资料的字节码了， 不会根据机器的各种分辨率来自动适应，使用了decodeStream之后，需要在hdpi和mdpi，ldpi中配置相应的图片资源，否则在不同分辨率机器上都是同样大小（像素点数量），显示出来的大小就不对了。
</content>
    </entry>
    
     <entry>
        <title>Go Socket例子</title>
        <url>http://xuzhibin.com/post/2012/go-socket/</url>
        <categories>
          <category>go</category>
        </categories>
        <tags>
          <tag>socket</tag>
        </tags>
        <content type="html">  Tcp Server (tcpserver.go) package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net&amp;#34; &amp;#34;os&amp;#34; &amp;#34;time&amp;#34; ) func main() { service := &amp;#34;:1200&amp;#34; tcpAddr, err := net.ResolveTCPAddr(&amp;#34;tcp4&amp;#34;, service) checkError(err) listener, err := net.ListenTCP(&amp;#34;tcp&amp;#34;, tcpAddr) checkError(err) for { conn, err := listener.Accept() if err != nil { continue } go handleClient(conn) } } func handleClient(conn net.Conn) { defer conn.Close() daytime := time.Now().String() fmt.Fprintf(os.Stderr,&amp;#34;connect time:%s,client ip:%s\r\n&amp;#34;,daytime,conn.RemoteAddr().String()) _,err := conn.Write([]byte(daytime)) // don&amp;#39;t care about return value  checkError(err) fmt.Fprintf(os.Stderr,&amp;#34;send time:%s\r\n&amp;#34;,daytime) // we&amp;#39;re finished with this client } func checkError(err error) { if err != nil { fmt.Fprintf(os.Stderr, &amp;#34;Fatal error: %s&amp;#34;, err.Error()) os.Exit(1) } } Tcp Client (tcpclient.go) tcpclient 192.0.0.1:1200 | tcpclient baidu.com:80 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net&amp;#34; &amp;#34;os&amp;#34; ) func main() { if len(os.Args) != 2 { fmt.Fprintf(os.Stderr, &amp;#34;Usage: %s host:port &amp;#34;, os.Args[0]) os.Exit(1) } service := os.Args[1] tcpAddr, err := net.ResolveTCPAddr(&amp;#34;tcp4&amp;#34;, service) checkError(err) conn, err := net.DialTCP(&amp;#34;tcp&amp;#34;, nil, tcpAddr) checkError(err) _, err = conn.Write([]byte(&amp;#34;HEAD / HTTP/1.0\r\n\r\n&amp;#34;)) checkError(err) result := make([]byte, 1024) _,err = conn.Read(result) checkError(err) fmt.Println(&amp;#34;receive from server:\r\n&amp;#34;) fmt.Println(string(result)) os.Exit(0) } func checkError(err error) { if err != nil { fmt.Fprintf(os.Stderr, &amp;#34;Fatal error: %s&amp;#34;, err.Error()) os.Exit(1) } }</content>
    </entry>
    
     <entry>
        <title>ElasticSearch入门笔记</title>
        <url>http://xuzhibin.com/post/2012/elasticsearch-getstart/</url>
        <categories>
          <category>server</category>
        </categories>
        <tags>
          <tag>elasticsearch</tag>
        </tags>
        <content type="html">  ElasticSearch 是构建在Apache Lucene之上的的搜索引擎服务，开源（Apache2协议），分布式，RESTful。安装方便，使用简单。
官方站点：http://www.elasticsearch.com/
中文站点：http://es-cn.medcl.net/
安装 必须先安装Java环境，并设置 JAVA_HOME =&amp;gt; C:\Program Files\Java\jdk1.6.0_18
elasticsearch-rtf 中文入门集成包 https://github.com/medcl/elasticsearch-rtf 使用git签出，下载到本地。windows下，执行bin下面的elasticsearch.bat。linux下，执行bin下面或者service下面elasticsearch。
Pyes https://github.com/aparo/pyes 更多客户端
Bottle http://bottlepy.org/docs/dev/
角色关系对照 elasticsearch 跟 MySQL 中定义资料格式的角色关系对照表如下
   MySQL helasticsearch     database index   table type   row document   field field    索引映射 #创建索引 $ curl -XPUT http://localhost:9200/test-index #创建Mapping $ curl -XPUT http://localhost:9200/test-index/test-type/_mapping -d &amp;#39;{ &amp;#34;properties&amp;#34; : { &amp;#34;name&amp;#34; : { &amp;#34;type&amp;#34; : &amp;#34;string&amp;#34; } } }&amp;#39;@route(&amp;#39;/indexsetting/&amp;#39;) def indexmapping(): &amp;#34;&amp;#34;&amp;#34;索引映射&amp;#34;&amp;#34;&amp;#34; conn = ES(&amp;#39;127.0.0.1:9200&amp;#39;) conn.debug_dump = True try: #删除索引 conn.delete_index(&amp;#34;test-index&amp;#34;) except: pass #创建索引 conn.create_index(&amp;#34;test-index&amp;#34;) mapping = { u&amp;#39;id&amp;#39;: {&amp;#39;store&amp;#39;: &amp;#39;yes&amp;#39;, &amp;#39;type&amp;#39;: u&amp;#39;integer&amp;#39;}, u&amp;#39;author&amp;#39;: {&amp;#39;boost&amp;#39;: 1.0, &amp;#39;index&amp;#39;: &amp;#39;not_analyzed&amp;#39;, &amp;#39;store&amp;#39;: &amp;#39;yes&amp;#39;, &amp;#39;type&amp;#39;: u&amp;#39;string&amp;#39;}, u&amp;#39;published&amp;#39;: {&amp;#39;boost&amp;#39;: 1.0, &amp;#39;index&amp;#39;: &amp;#39;not_analyzed&amp;#39;, &amp;#39;store&amp;#39;: &amp;#39;yes&amp;#39;, &amp;#39;type&amp;#39;: u&amp;#39;datetime&amp;#39;}, u&amp;#39;url&amp;#39;: {&amp;#39;store&amp;#39;: &amp;#39;yes&amp;#39;, &amp;#39;type&amp;#39;: u&amp;#39;string&amp;#39;}, u&amp;#39;title&amp;#39;: {&amp;#39;boost&amp;#39;: 1.0, &amp;#39;index&amp;#39;: &amp;#39;analyzed&amp;#39;, &amp;#39;store&amp;#39;: &amp;#39;yes&amp;#39;, &amp;#39;type&amp;#39;: u&amp;#39;string&amp;#39;}, u&amp;#39;content&amp;#39;: {&amp;#39;boost&amp;#39;: 1.0, &amp;#39;index&amp;#39;: &amp;#39;analyzed&amp;#39;, &amp;#39;store&amp;#39;: &amp;#39;yes&amp;#39;, &amp;#39;type&amp;#39;: u&amp;#39;string&amp;#39;, &amp;#34;term_vector&amp;#34; : &amp;#34;with_positions_offsets&amp;#34;} } #索引映射 conn.put_mapping(&amp;#34;test-type&amp;#34;, {&amp;#39;properties&amp;#39;:mapping}, [&amp;#34;test-index&amp;#34;]) return &amp;#34;索引映射&amp;#34; 索引 #索引 $ curl -XPUT http://localhost:9200/test-index/test-type/1 -d &amp;#39;{ &amp;#34;user&amp;#34;: &amp;#34;kimchy&amp;#34;, &amp;#34;post_date&amp;#34;: &amp;#34;2009-11-15T13:12:00&amp;#34;, &amp;#34;message&amp;#34;: &amp;#34;Trying out elasticsearch, so far so good?&amp;#34; }&amp;#39; #获取 $ curl -XGET http://localhost:9200/test-index/test-type/1 #删除 $ curl -XDELETE &amp;#39;http://localhost:9200/test-index/test-type/1&amp;#39;@route(&amp;#39;/indextest/&amp;#39;) def indexTest(): &amp;#34;&amp;#34;&amp;#34;索引测试&amp;#34;&amp;#34;&amp;#34; conn = ES(&amp;#39;127.0.0.1:9200&amp;#39;) for item in Data().getData(): #添加索引 conn.index(item,&amp;#34;test-index&amp;#34;, &amp;#34;test-type&amp;#34;,item[&amp;#39;id&amp;#39;]) #索引优化 conn.optimize([&amp;#34;test-index&amp;#34;]) #删除索引内容 conn.delete(&amp;#34;test-index&amp;#34;, &amp;#34;test-type&amp;#34;, 2668090) #更新索引内容 model = conn.get(&amp;#34;test-index&amp;#34;, &amp;#34;test-type&amp;#34;, 2667371) model[&amp;#34;title&amp;#34;]=&amp;#34;标题修改测试&amp;#34; conn.update(model,&amp;#34;test-index&amp;#34;, &amp;#34;test-type&amp;#34;,2667371) #刷新索引 conn.refresh([&amp;#34;test-index&amp;#34;]) q = MatchAllQuery() results = conn.search(query = q,indices=&amp;#34;test-index&amp;#34;, doc_types=&amp;#34;test-type&amp;#34;) # for r in results: # print r return template(&amp;#39;default.tpl&amp;#39;, list=results,count=len(results)) 搜索 #lucene语法方式的查询 $ curl -XGET http://localhost:9200/test-index/test-type/_search?q=user:kimchy #query DSL方式查询 $ curl -XGET http://localhost:9200/test-index/test-type/_search -d &amp;#39;{ &amp;#34;query&amp;#34; : { &amp;#34;term&amp;#34; : { &amp;#34;user&amp;#34;: &amp;#34;kimchy&amp;#34; } } }&amp;#39; #query DSL方式查询 $ curl -XGET http://localhost:9200/test-index/_search?pretty=true -d &amp;#39;{ &amp;#34;query&amp;#34; : { &amp;#34;range&amp;#34; : { &amp;#34;post_date&amp;#34; : { &amp;#34;from&amp;#34; : &amp;#34;2009-11-15T13:00:00&amp;#34;, &amp;#34;to&amp;#34; : &amp;#34;2009-11-15T14:30:00&amp;#34; } } } }&amp;#39; #查找全部索引内容 $ curl -XGET http://localhost:9200/test-index/test-type/_search?pretty=true@route(&amp;#39;/search/&amp;#39;) @route(&amp;#39;/search/&amp;lt;searchkey&amp;gt;&amp;#39;) def search(searchkey=u&amp;#34;关键算法&amp;#34;): &amp;#34;&amp;#34;&amp;#34;索引搜索&amp;#34;&amp;#34;&amp;#34; conn = ES(&amp;#39;127.0.0.1:9200&amp;#39;) #TextQuery会对searchkey进行分词 qtitle = TextQuery(&amp;#34;title&amp;#34;, searchkey) qcontent = TextQuery(&amp;#34;content&amp;#34;, searchkey) #发布时间大于&amp;#34;2012-9-2 22:00:00&amp;#34; qpublished=RangeQuery(ESRangeOp(&amp;#34;published&amp;#34;, &amp;#34;gt&amp;#34;, datetime(2012, 9, 2, 22, 0, 0))) h = HighLighter([&amp;#39;&amp;lt;b&amp;gt;&amp;#39;], [&amp;#39;&amp;lt;/b&amp;gt;&amp;#39;], fragment_size=500) #多字段搜索(must=&amp;gt;and,should=&amp;gt;or)，高亮，结果截取（分页），排序 q = Search(BoolQuery(must=[qpublished],should=[qtitle,qcontent]), highlight=h, start=0, size=3, sort={&amp;#39;id&amp;#39;: {&amp;#39;order&amp;#39;: &amp;#39;asc&amp;#39;}}) q.add_highlight(&amp;#34;title&amp;#34;) q.add_highlight(&amp;#34;content&amp;#34;) results = conn.search(query = q,indices=&amp;#34;test-index&amp;#34;, doc_types=&amp;#34;test-type&amp;#34;) list=[] for r in results: if(r._meta.highlight.has_key(&amp;#34;title&amp;#34;)): r[&amp;#39;title&amp;#39;]=r._meta.highlight[u&amp;#34;title&amp;#34;][0] if(r._meta.highlight.has_key(&amp;#34;content&amp;#34;)): r[&amp;#39;content&amp;#39;]=r._meta.highlight[u&amp;#34;content&amp;#34;][0] list.append(r) return template(&amp;#39;search.tpl&amp;#39;, list=list,count=results.total) 设置 #创建索引，并设置分片和副本参数 $ curl -XPUT http://localhost:9200/elasticsearch/ -d &amp;#39;{ &amp;#34;settings&amp;#34; : { &amp;#34;number_of_shards&amp;#34; : 2, &amp;#34;number_of_replicas&amp;#34; : 3 } }&amp;#39; 其他 #分词 curl -XGET &amp;#39;http://localhost:9200/test-index/_analyze?text=中华人民共和国&amp;#39; 例子程序下载
</content>
    </entry>
    
     <entry>
        <title>安装Tornado</title>
        <url>http://xuzhibin.com/post/2012/install-tornado/</url>
        <categories>
          <category>server</category>
        </categories>
        <tags>
          <tag>tornado</tag>
        </tags>
        <content type="html"> 安装Tornado
wget https://github.com/downloads/facebook/tornado/tornado-2.2.1.tar.gz tar xvzf tornado-2.2.1.tar.gz cd tornado-2.2.1 python setup.py build python setup.py install 到此，tornado已安装完成。
开启服务，运行hello world程序
cd tornado-2.2.1 ./demos/helloworld/helloworld.py 　此时打开浏览器，地址栏输入：http://127.0.0.1:8888，即可看到hello，world
也可以通过命令行查看
python -m tornado.httpclient http://127.0.0.1:8888 如果连接不上可以打开iptables的配置文件：
vi /etc/sysconfig/iptables 看看是否没有开放端口，修改后重启iptables
service iptables restart 例，开放8000~8999端口：
-A POSTROUTING -p tcp -m state --state NEW -m tcp --dport 8000:8999 -j ACCEPT</content>
    </entry>
    
     <entry>
        <title>mongodb常用命令</title>
        <url>http://xuzhibin.com/post/2012/mongodb-command/</url>
        <categories>
          <category>server</category>
        </categories>
        <tags>
          <tag>mongodb</tag>
        </tags>
        <content type="html">  超级用户相关 #进入数据库admin use admin #增加或修改用户密码 db.addUser(&amp;#39;name&amp;#39;,&amp;#39;pwd&amp;#39;) #查看用户列表 db.system.users.find() #用户认证 db.auth(&amp;#39;name&amp;#39;,&amp;#39;pwd&amp;#39;) #删除用户 db.removeUser(&amp;#39;name&amp;#39;) #查看所有用户 show users #查看所有数据库 show dbs #查看所有的collection show collections #查看各collection的状态 db.printCollectionStats() #查看主从复制状态 db.printReplicationInfo() #修复数据库 db.repairDatabase() #设置记录profiling，0=off 1=slow 2=all db.setProfilingLevel(1) #查看profiling show profile #拷贝数据库 db.copyDatabase(&amp;#39;mail_addr&amp;#39;,&amp;#39;mail_addr_tmp&amp;#39;) #删除collection db.mail_addr.drop() #删除当前的数据库 db.dropDatabase()  增删改 #存储嵌套的对象 db.foo.save({&amp;#39;name&amp;#39;:&amp;#39;ysz&amp;#39;,&amp;#39;address&amp;#39;:{&amp;#39;city&amp;#39;:&amp;#39;beijing&amp;#39;,&amp;#39;post&amp;#39;:100096},&amp;#39;phone&amp;#39;:[138,139]}) #存储数组对象 db.user_addr.save({&amp;#39;Uid&amp;#39;:&amp;#39;yushunzhi@sohu.com&amp;#39;,&amp;#39;Al&amp;#39;:[&amp;#39;test-1@sohu.com&amp;#39;,&amp;#39;test-2@sohu.com&amp;#39;]}) #根据query条件修改，如果不存在则插入，允许修改多条记录 db.foo.update({&amp;#39;yy&amp;#39;:5},{&amp;#39;$set&amp;#39;:{&amp;#39;xx&amp;#39;:2}},upsert=true,multi=true) #删除yy=5的记录 db.foo.remove({&amp;#39;yy&amp;#39;:5}) #删除所有的记录 db.foo.remove()  索引 #增加索引：1(ascending),-1(descending) db.foo.ensureIndex({firstname: 1, lastname: 1}, {unique: true}); #索引子对象 db.user_addr.ensureIndex({&amp;#39;Al.Em&amp;#39;: 1}) #查看索引信息 db.foo.getIndexes() db.foo.getIndexKeys() #根据索引名删除索引 db.user_addr.dropIndex(&amp;#39;Al.Em_1&amp;#39;)  查询 #查找所有 db.foo.find() #查找一条记录 db.foo.findOne() #根据条件检索10条记录 db.foo.find({&amp;#39;msg&amp;#39;:&amp;#39;Hello 1&amp;#39;}).limit(10) #sort排序 db.deliver_status.find({&amp;#39;From&amp;#39;:&amp;#39;ixigua@sina.com&amp;#39;}).sort({&amp;#39;Dt&amp;#39;,-1}) db.deliver_status.find().sort({&amp;#39;Ct&amp;#39;:-1}).limit(1) #count操作 db.user_addr.count() #distinct操作,查询指定列，去重复 db.foo.distinct(&amp;#39;msg&amp;#39;) #”&amp;amp;gt;=”操作 db.foo.find({&amp;#34;timestamp&amp;#34;: {&amp;#34;$gte&amp;#34; : 2}}) #子对象的查找 db.foo.find({&amp;#39;address.city&amp;#39;:&amp;#39;beijing&amp;#39;})  管理 #查看collection数据的大小 db.deliver_status.dataSize() #查看colleciont状态 db.deliver_status.stats() #查询所有索引的大小 db.deliver_status.totalIndexSize()  advanced queries:高级查询 #条件操作符 $gt : &amp;gt; $gte: &amp;gt; = $lt : &amp;lt; , $lte: &amp;lt; = $ne : !=、&amp;lt;&amp;gt; $in : in $nin: not in $all: all $not: 反匹配(1.3.3及以上版本) #查询 name &amp;lt;&amp;gt; &amp;#34;bruce&amp;#34; and age &amp;gt;= 18 的数据 db.users.find({name: {$ne: &amp;#34;bruce&amp;#34;}, age: {$gte: 18}}); #查询 creation_date &amp;gt; &amp;#39;2010-01-01&amp;#39; and creation_date &amp;lt; = &amp;#39;2010-12-31&amp;#39; 的数据 db.users.find({creation_date:{$gt:new Date(2010,0,1), $lte:new Date(2010,11,31)}); #查询 age in (20,22,24,26) 的数据 db.users.find({age: {$in: [20,22,24,26]}}); #查询 age取模10等于0 的数据 db.users.find(&amp;#39;this.age % 10 == 0&amp;#39;); #或者 db.users.find({age : {$mod : [10, 0]}}); #匹配所有 db.users.find({favorite_number : {$all : [6, 8]}}); #可以查询出 {name: &amp;#39;David&amp;#39;, age: 26, favorite_number: [ 6, 8, 9 ] } #可以不查询出 {name: &amp;#39;David&amp;#39;, age: 26, favorite_number: [ 6, 7, 9 ] } #查询不匹配name=B*带头的记录 db.users.find({name: {$not: /^B.*/}}); #查询 age取模10不等于0 的数据 db.users.find({age : {$not: {$mod : [10, 0]}}}); #返回部分字段 #选择返回age和_id字段(_id字段总是会被返回) db.users.find({}, {age:1}); db.users.find({}, {age:3}); db.users.find({}, {age:true}); db.users.find({ name : &amp;#34;bruce&amp;#34; }, {age:1}); 0为false, 非0为true #选择返回age、address和_id字段 db.users.find({ name : &amp;#34;bruce&amp;#34; }, {age:1, address:1}); #排除返回age、address和_id字段 db.users.find({}, {age:0, address:false}); db.users.find({ name : &amp;#34;bruce&amp;#34; }, {age:0, address:false}); #数组元素个数判断 #对于{name: &amp;#39;David&amp;#39;, age: 26, favorite_number: [ 6, 7, 9 ] }记录 #匹配 db.users.find({favorite_number: {$size: 3}}); #不匹配 db.users.find({favorite_number: {$size: 2}}); #$exists判断字段是否存在 #查询所有存在name字段的记录 db.users.find({name: {$exists: true}}); #查询所有不存在phone字段的记录 db.users.find({phone: {$exists: false}}); #$type判断字段类型 #查询所有name字段是字符类型的 db.users.find({name: {$type: 2}}); #查询所有age字段是整型的 db.users.find({age: {$type: 16}}); #对于字符字段，可以使用正则表达式 #查询以字母b或者B带头的所有记录 db.users.find({name: /^b.*/i}); #$elemMatch(1.3.1及以上版本) #为数组的字段中匹配其中某个元素 #Javascript查询和$where查询 #查询 age &amp;gt; 18 的记录，以下查询都一样 db.users.find({age: {$gt: 18}}); db.users.find({$where: &amp;#34;this.age &amp;gt; 18&amp;#34;}); db.users.find(&amp;#34;this.age &amp;gt; 18&amp;#34;); f = function() {return this.age &amp;gt; 18} db.users.find(f); #排序sort() #以年龄升序asc db.users.find().sort({age: 1}); #以年龄降序desc db.users.find().sort({age: -1}); #限制返回记录数量limit() #返回5条记录 db.users.find().limit(5); #返回3条记录并打印信息 db.users.find().limit(3).forEach(function(user) {print(&amp;#39;my age is &amp;#39; &#43; user.age)}); 结果 my age is 18 my age is 19 my age is 20 #限制返回记录的开始点skip() #从第3条记录开始，返回5条记录(limit 3, 5) db.users.find().skip(3).limit(5); #查询记录条数count() db.users.find().count(); db.users.find({age:18}).count(); #以下返回的不是5，而是user表中所有的记录数量 db.users.find().skip(10).limit(5).count(); #如果要返回限制之后的记录数量，要使用count(true)或者count(非0) db.users.find().skip(10).limit(5).count(true); #分组group() #假设test表只有以下一条数据 { domain: &amp;#34;www.mongodb.org&amp;#34; , invoked_at: {d:&amp;#34;2009-11-03&amp;#34;, t:&amp;#34;17:14:05&amp;#34;} , response_time: 0.05 , http_action: &amp;#34;GET /display/DOCS/Aggregation&amp;#34; } #使用group统计test表11月份的数据count:count(*)、total_time:sum(response_time)、avg_time:total_time/count; db.test.group( { cond: {&amp;#34;invoked_at.d&amp;#34;: {$gt: &amp;#34;2009-11&amp;#34;, $lt: &amp;#34;2009-12&amp;#34;}} , key: {http_action: true} , initial: {count: 0, total_time:0} , reduce: function(doc, out){ out.count&#43;&#43;; out.total_time&#43;=doc.response_time } , finalize: function(out){ out.avg_time = out.total_time / out.count } } ); [ { &amp;#34;http_action&amp;#34; : &amp;#34;GET /display/DOCS/Aggregation&amp;#34;, &amp;#34;count&amp;#34; : 1, &amp;#34;total_time&amp;#34; : 0.05, &amp;#34;avg_time&amp;#34; : 0.05 } ] </content>
    </entry>
    
     <entry>
        <title>移动WebApp开发记录</title>
        <url>http://xuzhibin.com/post/2011/webapp-devlog/</url>
        <categories>
          <category>ui</category>
        </categories>
        <tags>
          <tag>webapp</tag>
        </tags>
        <content type="html"> 这段时间在做移动WebApp开发，基于PhoneGap&#43;Jquery Mobile，遇到不少问题，下面进行部分总结。
1.webStorage有大小限制(5M)，Chrome出现”QUOTA_EXCEEDED_ERR: DOM Exception 22″错误，极有可能因为webStorage缓存的问题。
2.localStorage只能存字符串，不能存对象。
3.Jquery的Html(str)函数会将str里的内容进行过滤，遇到显示有问题，可使用(“.show”)[0].innerHTML=str代替。
4.对于xml字符串，如果用jquery操作，需转换为xml对象，$.parseXML(source)。对于从接口返回的xml，Jquery可以设置指定返回xml对象。
5.Jquery Mobile在不同的页面切换，Android有明显的卡顿及闪屏感觉。
$.mobile.showPageLoadingMsg()不生效。
A1.Android有明显的卡顿及闪屏感觉，据说是因为其对CSS3支持不好。
A2.Jquery Mobile在不同的页面切换，需要Loading效果的可以试下以下代码:
function w2mTransitionHandler( name, reverse, $to, $from ) { $(&amp;#34;.ui-loader&amp;#34;).css({&amp;#34;display&amp;#34;: &amp;#34;block&amp;#34;, &amp;#34;top&amp;#34;: &amp;#34;252px !important&amp;#34; }); var deferred = new $.Deferred(), reverseClass = reverse ? &amp;#34; reverse&amp;#34; : &amp;#34;&amp;#34;, viewportClass = &amp;#34;ui-mobile-viewport-transitioning viewport-&amp;#34; &#43; name, doneFunc = function() { $to.add( $from ).removeClass( &amp;#34;out in reverse &amp;#34; &#43; name ); if ( $from &amp;amp;&amp;amp; $from[ 0 ] !== $to[ 0 ] ) { $from.removeClass( $.mobile.activePageClass ); } $to.parent().removeClass( viewportClass ); $(&amp;#34;.ui-loader&amp;#34;).css({ &amp;#34;display&amp;#34;: &amp;#34;none&amp;#34; }); deferred.resolve( name, reverse, $to, $from ); }; $to.animationComplete( doneFunc ); $to.parent().addClass( viewportClass ); if ( $from ) { $from.addClass( name &#43; &amp;#34; out&amp;#34; &#43; reverseClass ); } $to.addClass( $.mobile.activePageClass &#43; &amp;#34; &amp;#34; &#43; name &#43; &amp;#34; in&amp;#34; &#43; reverseClass ); return deferred.promise(); } $.mobile.defaultTransitionHandler = w2mTransitionHandler;  A3.$.mobile.showPageLoadingMsg()有时会不生效，考虑以下代码：
$(&amp;#34;:button&amp;#34;).click(function(){ //position:fixed;top: 252px !important; display: block;  $(&amp;#34;.ui-loader&amp;#34;).css({&amp;#34;top&amp;#34;: &amp;#34;252 !important&amp;#34;,&amp;#34;position&amp;#34;:&amp;#34;fixed&amp;#34;}); $(&amp;#34;.ui-loader&amp;#34;).show(&amp;#34;normal&amp;#34;, function () { var list = new ListData(channelid, num, channelname); list.getData(); if(list.list.length==0) { alert(&amp;#34;已是最后一页&amp;#34;); } else { list.showData(); num&#43;&#43;; } $(&amp;#34;.ui-loader&amp;#34;).hide(&amp;#34;normal&amp;#34;); }); }) </content>
    </entry>
    
     <entry>
        <title>悟透JavaScript笔记</title>
        <url>http://xuzhibin.com/post/2011/understand-javascript/</url>
        <categories>
          <category>ui</category>
        </categories>
        <tags>
          <tag>javascript</tag>
        </tags>
        <content type="html"> 原生闭包
function Person(firstName, lastName, age) { //私有变量：  var _firstName = firstName; var _lastName = lastName; //公共变量:  this.age = age; //方法：  this.getName = function() { return(firstName &#43; &amp;#34; &amp;#34; &#43; lastName); }; this.SayHello = function() { alert(&amp;#34;Hello, I&amp;#39;m &amp;#34; &#43; firstName &#43; &amp;#34; &amp;#34; &#43; lastName); }; }; var BillGates = new Person(&amp;#34;Bill&amp;#34;, &amp;#34;Gates&amp;#34;, 53); var SteveJobs = new Person(&amp;#34;Steve&amp;#34;, &amp;#34;Jobs&amp;#34;, 53); BillGates.SayHello(); SteveJobs.SayHello(); alert(BillGates.getName() &#43; &amp;#34; &amp;#34; &#43; BillGates.age); alert(BillGates.firstName); //这里不能访问到私有变量  甘露模型
//定义类的语法甘露：Class() //最后一个参数是JSON表示的类定义 //如果参数数量大于1个，则第一个参数是基类 //第一个和最后一个之间参数，将来可表示类实现的接口 //返回值是类，类是一个构造函数 function Class() { var aDefine = arguments[arguments.length-1]; //最后一个参数是类定义  if(!aDefine) return; var aBase = arguments.length&amp;gt;1 ? arguments[0] : object; //解析基类  function prototype_(){}; //构造prototype的临时函数，用于挂接原型链  prototype_.prototype = aBase.prototype; //准备传递prototype  var aPrototype = new prototype_(); //建立类要用的prototype  for(var member in aDefine) //复制类定义到当前类的prototype  if(member!=&amp;#34;Create&amp;#34;) //构造函数不用复制  aPrototype[member] = aDefine[member]; //根据是否继承特殊属性和性能情况，可分别注释掉下列的语句  if(aDefine.toString != Object.prototype.toString) aPrototype.toString = aDefine.toString; if(aDefine.toLocaleString != Object.prototype.toLocaleString) aPrototype.toLocaleString = aDefine.toLocaleString; if(aDefine.valueOf != Object.prototype.valueOf) aPrototype.valueOf = aDefine.valueOf; if(aDefine.Create) //若有构造函数  var aType = aDefine.Create //类型即为该构造函数  else //否则为默认构造函数  aType = function() { this.base.apply(this, arguments); //调用基类构造函数  }; aType.prototype = aPrototype; //设置类(构造函数)的prototype  aType.Base = aBase; //设置类型关系，便于追溯继承关系  aType.prototype.Type = aType; //为本类对象扩展一个Type属性  return aType; //返回构造函数作为类 }; //根类object定义： function object(){} //定义小写的object根类，用于实现最基础的方法等 object.prototype.isA = function(aType) //判断对象是否属于某类型 { var self = this.Type; while(self) { if(self == aType) return true; self = self.Base; }; return false; }; object.prototype.base = function() //调用基类构造函数 { var Base = this.Type.Base; //获取当前对象的基类  if(!Base.Base) //若基类已没有基类  Base.apply(this, arguments) //则直接调用基类构造函数  else //若基类还有基类  { this.base = MakeBase(Base); //先覆写this.base  Base.apply(this, arguments); //再调用基类构造函数  delete this.base; //删除覆写的base属性  }; function MakeBase(Type) //包装基类构造函数  { var Base = Type.Base; if(!Base.Base) return Base; //基类已无基类，就无需包装  return function() //包装为引用临时变量Base的闭包函数  { this.base = MakeBase(Base); //先覆写this.base  Base.apply(this, arguments); //再调用基类构造函数  }; }; }; //语法甘露的应用效果： var Person = Class //默认派生自object基本类 ({ Create: function(name, age) { this.base(); //调用上层构造函数  this.name = name; this.age = age; }, SayHello: function() { alert(&amp;#34;Hello, I&amp;#39;m &amp;#34; &#43; this.name &#43; &amp;#34;, &amp;#34; &#43; this.age &#43; &amp;#34; years old.&amp;#34;); }, toString: function() //覆写toString方法  { return this.name; } }); var Employee = Class(Person, //派生自Person类 { Create: function(name, age, salary) { this.base(name, age); //调用基类的构造函数  this.salary = salary; }, ShowMeTheMoney: function() { alert(this &#43; &amp;#34; $&amp;#34; &#43; this.salary); //这里直接引用this将隐式调用toString()  } }); var BillGates = new Person(&amp;#34;Bill Gates&amp;#34;, 53); var SteveJobs = new Employee(&amp;#34;Steve Jobs&amp;#34;, 53, 1234); alert(BillGates); //这里将隐式调用覆写后的toString()方法 BillGates.SayHello(); SteveJobs.SayHello(); SteveJobs.ShowMeTheMoney(); var LittleBill = new BillGates.Type(&amp;#34;Little Bill&amp;#34;, 6); //用BillGate的类型建LittleBill LittleBill.SayHello(); alert(BillGates.isA(Person)); //true alert(BillGates.isA(Employee)); //false alert(SteveJobs.isA(Person)); //true  参考资料：
悟透JavaScript
http://www.cnblogs.com/leadzen/archive/2008/02/25/1073404.html
悟透JavaScript 之 甘露模型（新）
http://www.cnblogs.com/leadzen/archive/2008/06/04/1213090.html
</content>
    </entry>
    
     <entry>
        <title>HTML5笔记-web本地存储</title>
        <url>http://xuzhibin.com/post/2011/h5-storage/</url>
        <categories>
          <category>ui</category>
        </categories>
        <tags>
          <tag>html5</tag>
        </tags>
        <content type="html"> Web Storage就是放大版的cookie——提供了比cookie更大的本地存储，并且不会向服务器发出请求，并提供了一些API。总之本地存储能更专业地处理本地数据。 可以像对象字面量那样使用Web Storage：
localStorage.fresh = &amp;#34;vfresh.org&amp;#34;; //设置一个键值 var a = localStorage.fresh; //获取键值 delete localStorage[&amp;#39;fresh&amp;#39;] //删除键值  或者使用它的API：
//清空storage localStorage.clear(); //设置一个键值 localStorage.setItem(&amp;#34;fresh&amp;#34;,&amp;#34;vfresh.org&amp;#34;); //获取一个键值 localStorage.getItem(&amp;#34;fresh&amp;#34;); //return &amp;#34;vfresh.org&amp;#34; //获取指定下标的键的名称（如同Array） localStorage.key(0); //return &amp;#34;fresh&amp;#34; //删除一个键值 localStorage.removeItem(&amp;#34;fresh&amp;#34;);  字面量方式比API更高效，也更方便，所以你懂的。
localStorage是永久性的保存，而sessionStorage在浏览器窗口关闭后就没有了（相当于Expire=0的cookie）。
支持浏览器：IE 8&#43;, Firefox 3.0&#43;, Safari 4.0&#43;, Chrome 4.0&#43;, Opera 10.5&#43;
</content>
    </entry>
    
     <entry>
        <title>HTML5笔记-地理定位</title>
        <url>http://xuzhibin.com/post/2011/h5-location/</url>
        <categories>
          <category>ui</category>
        </categories>
        <tags>
          <tag>html5</tag>
        </tags>
        <content type="html"> 地理定位（Geolocation）是一个可以获取到客户端经纬度等地理位置信息的API。 API本身是不知道客户端地理信息的，常见的地理位置信息来源有全球定位系统(GPS)和从网络信号中推断出的地理信息（如IP地址, RFID, WIFI, 蓝牙MAC地址, GSM/CDMA手机id,以及用户输入的信息 ）
先来了解下Geolocation API：
//返回地理定位对象 var geo = navigator.geolocation; /* *方法,获取当前客户端地理位置 *有三个参数可以用 *successCallback：必需,函数,获取成功后的回调函数 *errorCallback：可选,函数,失败时的回调函数 *options：可选,对象字面量,有三个值可设定： * enableHighAccuracy：是否启用高精度设备（高精度设备包含但不局限于前面所提到的 GPS 和 WIFI） * maximumAge：数值,如果将其定义为负数或者未定义，会重设为0 * timeout：数值,请求获取地理信息时的超时时间，如果将其定义为负数会重设为0，如果未定义则不启用超时判断 */ geo.getCurrentPosition(successCallback,errorCallback,options); /* *方法,持续监控当前客户端地理位置（实时） *返回该watchPosition的id*参数同getCurrentPosition */ var watchGEO = geo.watchPosition(successCallback,errorCallback,options); /*方法,结束指定ID的watchPosition*/ geo.clearWatch(watchId);  使用地理定位API需要获得用户的许可，如果没有，会执行errorCallback；
watchPosition的successCallback只有在获取到的实时地理位置和之前有较大不同时才会执行；
getCurrentPosition和watchPosition的successCallback都有一个position参数，它包含有详细的地理信息如经纬度：
geo.getCurrentPosition(function (pos) {//成功获取时执行  var coord = pos.coords, //坐标detail  accuracy = coord.accuracy, //精准度，单位为米  latitude = coord.latitude, //纬度  longitude = coord.longitude, //经度  altitudeAccuracy = coord.altitudeAccuracy, //高度精确度，单位为米  heading = coord.heading, //移动的方向  speed = coord.speed; //速度  showLocationInfo(coord,‘map’); //显示坐标信息  showMap(coord,‘map’); //显示google地图  }, function (error) {//获取失败时执行  alert(‘error:’&#43;error.message&#43;‘\n\n无法获得您的地理位置：’); });  取到经纬度就可以利用各map服务商的app来显示地图，如google map
</content>
    </entry>
    
     <entry>
        <title>HTML5笔记-离线应用</title>
        <url>http://xuzhibin.com/post/2011/h5-offlineapp/</url>
        <categories>
          <category>ui</category>
        </categories>
        <tags>
          <tag>html5</tag>
        </tags>
        <content type="html"> 为了能够让用户在离线状态下继续访问 Web 应用，需要一种方式来指明应用程序离线工作时所需的资源文件。这样，浏览器才能在在线状态时，把这些文件缓存到本地。此后，当用户离线访问应用程序时，这些资源文件会自动加载，从而让用户正常使用。HTML5 中，通过 cache manifest 文件指明需要缓存的资源，并支持自动和手动两种缓存更新方式。
开发者需要提供一个 cache manifest 文件。这个文件中列出了所有需要在离线状态下使用的资源，浏览器会把这些资源缓存到本地。
我们通过 W3C 提供的示例来说明。Clock Web 应用由三个文件“clock.html”、“clock.css”和“clock.js”组成。
&amp;lt;!-- clock.html --&amp;gt; &amp;lt; !DOCTYPE HTML&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Clock&amp;lt;/title&amp;gt; &amp;lt;script src=&amp;#34;clock.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;clock.css&amp;#34;&amp;gt; &amp;lt;/link&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;The time is: &amp;lt;output id=&amp;#34;clock&amp;#34;&amp;gt;&amp;lt;/output&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; /* clock.css */ output { font: 2em sans-serif; } /* clock.js */ setTimeout(function () { document.getElementById(&amp;#39;clock&amp;#39;).value = new Date(); }, 1000); 当用户在离线状态下访问“clock.html”时，页面将无法展现。为了支持离线访问，开发者必须添加 cache manifest 文件，指明需要缓存的资源。这个例子中的 cache manifest 文件为“clock.manifest”，它声明了 3 个需要缓存的资源文件“clock.html”、“clock.css”和“clock.js”。 clock.manifest 代码
CACHE MANIFEST clock.html clock.css clock.js 添加了 cache manifest 文件后，还需要修改“clock.html”，把 标签的 manifest 属性设置为“clock.manifest”。修改后的“clock.html”代码如下。
&amp;lt;!-- clock.html --&amp;gt; &amp;lt; !DOCTYPE HTML&amp;gt; &amp;lt;html manifest=&amp;#34;clock.manifest&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Clock&amp;lt;/title&amp;gt; &amp;lt;script src=&amp;#34;clock.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;clock.css&amp;#34;&amp;gt; &amp;lt;/link&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;The time is: &amp;lt;output id=&amp;#34;clock&amp;#34;&amp;gt;&amp;lt;/output&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 修改后，当用户在线访问“clock.html”时，浏览器会缓存“clock.html”、“clock.css”和“clock.js”文件；而当用户离线访问时，这个 Web 应用也可以正常使用了。
注意：
manifest文件的MIME-type必须是text/cache-manifest （需要服务器端设置）
在测试中发现，各浏览器更新缓存的机制各异：chrome修改manifest就可以更新缓存了，但却无法加载manifest之外的资源；而firefox需要手动删除本地缓存数据。 种种的这些兼容性问题，可以给NETWORK添加上通配符*来修正：
NETWORK:*
具体的原因可能是在启用离线应用后浏览器不会加载manifest设定之外的资源；而且firefox等也把manifest文件给缓存了，导致无法获取最新的manifest资源列表。
下面说明书写 cache manifest 文件需要遵循的格式。
首行必须是 CACHE MANIFEST。
其后，每一行列出一个需要缓存的资源文件名。
需要注意的是一行一个文件，也可以使用绝对路径或者URLs。
可根据需要列出在线访问的白名单。白名单中的所有资源不会被缓存，在使用时将直接在线访问。声明白名单使用 NETWORK：标识符。
如果在白名单后还要补充需要缓存的资源，可以使用 CACHE：标识符。
如果要声明某 URI 不能访问时的替补 URI，可以使用 FALLBACK：标识符。其后的每一行包含两个 URI，当第一个 URI 不可访问时，浏览器将尝试使用第二个 URI。
注释要另起一行，以 # 号开头。
cache manifest 中各类标识符的使用示例。
CACHE MANIFEST # 上一行是必须书写的。 images/sound-icon.png images/background.png NETWORK: comm.cgi # 下面是另一些需要缓存的资源，在这个示例中只有一个 css 文件。 CACHE: style/default.css FALLBACK: /files/projects /projects 应用程序可以等待浏览器自动更新缓存，也可以使用 Javascript 接口手动触发更新。
1.自动更新
浏览器除了在第一次访问 Web 应用时缓存资源外，只会在 cache manifest 文件本身发生变化时更新缓存。而 cache manifest 中的资源文件发生变化并不会触发更新 。 2.手动更新
开发者也可以使用 window.applicationCache 的接口更新缓存。方法是检测 window.applicationCache.status 的值，如果是 UPDATEREADY，那么可以调用 window.applicationCache.update() 更新缓存。
现在来了解下离线应用的API：
/*当前文档的ApplicationCache对象*/ var cache = window.applicationCache; /* *当前worker的ApplicationCache对象*worker在本文第五节介绍 */ var cache = self.applicationCache; /* *属性,返回当前离线应用的状态 * UNCACHED (数值0)：未启用离线应用 * IDLE (数值1)：已开启离线应用，但本地缓存的资源是最新的，并且未标记为废弃资源 * CHECKING (数值2)：当前更新缓存的状态为“检查中” * DOWNLOADING (数值3)：当前更新缓存的状态为“下载资源中” * UPDATEREADY (数值4)：当前更新缓存的状态为“更新完毕” * OBSOLETE (数值5)：已开启离线应用，但缓存资源都已标记为废弃 */ cache.status /* *方法,下载资源到本地 *如果没有cache需要更新，则抛出 INVALID_STATE_ERR 异常 */ cache.update(); /* *方法,更新缓存到最新的资源 *如果没有新的资源，则抛出INVALID_STATE_ERR异常 *并不会使本次加载的页面立即重新加载资源，仅有在执行该方法后刷新页面才能看到最新的资源。 */ cache.swapCache();  事件处理器：
checkingEvent 检查是否需要更新，或者在第一次下载manifest文件时。 最先执行的事件。
noupdateEvent manifest 文件未修改，不需要更新。Last event in sequence.
downloadingEvent 需要更新缓存，或者第一次下载资源时。
progressProgressEvent 下载资源中。
cachedEvent 资源已下载完成，并且已完成缓存最后的事件。
updatereadyEvent 资源更新完毕，并且可以用swapCache()来启用新的缓存。最后的事件。
obsoleteEvent 加载manifest文件时遇到401或404错误，所以缓存将被删除。最后的事件。
errorEvent 加载manifest文件时遇到401或404错误，将中断缓存网页。最后的事件。
支持浏览器：Firefox 3.0, Safari 4.0, Chrome 5.0, Opera 10.6
</content>
    </entry>
    
     <entry>
        <title>iptables封ip段的一些常见命令</title>
        <url>http://xuzhibin.com/post/2011/iptables-blockip/</url>
        <categories>
          <category>linux</category>
        </categories>
        <tags>
          <tag>iptables</tag>
        </tags>
        <content type="html"> linux下使用iptables封ip段的一些常见命令：
封单个IP的命令
iptables -I INPUT -s 211.1.0.0 -j DROP 封IP段的命令
iptables -I INPUT -s 211.1.0.0/16 -j DROP iptables -I INPUT -s 211.2.0.0/16 -j DROP iptables -I INPUT -s 211.3.0.0/16 -j DROP 封整个段的命令
iptables -I INPUT -s 211.0.0.0/8 -j DROP 封几个段的命令
iptables -I INPUT -s 61.37.80.0/24 -j DROP iptables -I INPUT -s 61.37.81.0/24 -j DROP 封80端口
iptables -I INPUT -p tcp –dport 80 -s 124.115.0.0/24 -j DROP 解封的话
iptables -D INPUT -s IP地址 -j REJECT iptables -F 全清掉了 如果想开机就自动封锁某个IP，那就编辑/etc/sysconfig/iptables文件，添加一行
-I INPUT -s IP地址 -j DROP 然后执行/etc/init.d/iptables restart重启iptables。
</content>
    </entry>
    
     <entry>
        <title>网页正文提取算法研究[非正则]</title>
        <url>http://xuzhibin.com/post/2010/text-extraction/</url>
        <categories>
          <category>research</category>
        </categories>
        <tags>
          <tag>text extraction</tag><tag>正文抽取</tag><tag>正文提取</tag>
        </tags>
        <content type="html"> 互联网的页面展现形式相当丰富，但是如果按页面结构特征来分类，却不外乎以下几种类型：首页（包括栏目首页），列表页，内容页，评论页。
(1) **首页: **网站的首页, 一般含有多个栏目、图片、动画,以及若干文章标题链接。如: 网易首页。
(2) 列表页: 信息以列表的方式给出, 一般以表格的形式列出若干个条目, 经常含有分页功能。例如: 某论坛版面的文章标题列表。
(3) 内容页: 指含有正文内容的底层网页, 一般只含有不超过一篇的文章内容, 无评论或评论较少。如: 各类网站的含有具体某篇文章的底层网页。
(4) **评论页: **除了含有正文, 正文后面还跟有若干个评论,以论坛为代表。
在这几种类型之中，信息含量最大的当数内容页，它是我们平常摄取信息的主要来源。由于内容页的重要性，不同的Web站点为了加强内容页的展示，都会加入一些与内容相关或无关的信息块，如导航，广告等。虽然这些信息块在一定程度上有助于我们的延伸阅读，但很多情况下，我们只需要获取正文信息就可以了，其他信息块反倒成了一种干扰。如何从一个内容页面中，正确提取出正文信息，就成了一个研究课题。
在详述之前，先说一下正文提取的意义。以笔者的经历看来，应用包括但不限于以下几个方面。
(1) 采集，搜索。信息采集很常见，互联网上超过30%的内容都是从其他Web站点采集而来。现在的采集系统或工具，大多是基于页面的正则来进行信息采集的，这样的优点是，对于需要采集的信息精确度很高，但是缺点也是很明显的，由于是基于页面的Html源码来采集，一旦源站点改版或调整，导致页面的Html源码改变，所有正则将全部作废。而正文提取技术，不是以Html源码格式为依据，所以Html源码的改变相对来说影响不大。
(2) 门户文章发布。很多门户站点，并没有专门的记者团队，大部分文章都靠编辑在网上复制粘贴。如果能在发布界面加个功能，只需要输入网址，即可正确导入正文内容，并自动处理图片，想必是个不错的用户体验。
(3)Wap浏览器。Wap浏览由于受到流量及手机屏幕的限制，现在的Wap页面大部分以特出文字信息为主，但也不排除会有一些干扰信息块出现。作为用户，希望能只显示正文信息，特别是对于新闻及小说等页面。Wap浏览器如果可以将正文内容自动提取出来，应该是个不错功能。Android系统的迷人浏览器有个阅读模式，算是在这方面的一个探索。
正文提取技术的算法很多，本文是基于多特征的一种算法研究，根据信息块的特征进行判定。内容页又称为主题页，主题内容通常可以分解层次为: ①标题; ②发布时间; ③内容正文; ④相关文章或延伸性阅读。除了“内容正文”为必须元素外，其他几个元素都不一定会在内容页出现。根据对大量不同网页观察，各个元素的位置及表现形式虽无固定的标准，但是大部分却满足一定的特征。
一．标题块
 分块节点：td，div，h，span 一般位于Head/Title的位置 当前单元含有&amp;lt;h1&amp;gt;-&amp;lt;h3&amp;gt;，&amp;lt;b&amp;gt;，&amp;lt;i&amp;gt;，&amp;lt;strong&amp;gt;等标签 样式，一般class包含title，head等字符 文字长度，一般大于3个字符，小于35个字符  二．发表时间块
 分块节点：td，div， span 文字长度，一般小于50个字符 包含日期格式（2010-08-09）的字符串 包含以下关键字：来源，发表  三．主题块
 分块节点：td，div HTML网页中有一些特殊标签，通常只出现在网页主题块中，如&amp;lt;P&amp;gt; &amp;lt;BR&amp;gt;等。因此，主题块中往往包含着特殊标签。 主题块内容含有较多的句子，因此具有较多逗号、句号等标点符号（&amp;gt;5）。 若从信息量角度考虑，主题块一般是含有较多文字信息。 主题块的 标签密度=1000*标签数/文字数 应在小于一个范围。 主题块的 文本密度=len(文本)/len(HTML代码) 较大 不应该包含 “上一篇”，“下一篇” 包含以下字符串的内容块，判定为包含版权信息，需减权：“ICP备04000001号”，“版权所有”，“Copyright” 主题块序号在标题块之下 主题块序号在发表时间块之下 主题块序号在相关链接块之上  四．相关链接块
 分块节点：td，div 文字应为“相关链接”、“相关新闻”、“相关报道”等敏感词，且连接比例很高。 链接数小于20  实现：
根据以上信息块特征，采用特征提权算法，C#（3.5）编程实现，命名为QD正文提取组件。经测试，对Html格式规范的以文字为主的内容页，正确提取率在85%以上，各大门户的新闻页面在95%以上。
例子下载(需要安装Microsoft .NET Framework 3.5)
 注：QD正文提取组件 不开源，需要源码的朋友可选择付费获取。
 例子程序最新版本为 1.0.4.0
 所售源码包文件列表
组件源代码1份 (C#)
例子程序1个 (源码，运行界面见上图)
正文提取相关论文，找人到学校收费论文库下的，压缩包大概几十M
CAJViewer软件1个，看某些论文需要用到。
 针对近期部分朋友的咨询，答复如下：
1.物价高涨，生活不容易，砍价亦麻烦，组件源码价格调整为￥300，此为底线，不再接受议价。
2.购买前，请先确定此组件对你是有价值的，以免浪费金钱。
3.由于程序源码的特殊性，不提供退货服务，请谅解。源码的效果与例子程序是一模一样的，请先下载例子程序测试，看看是否能满足你的要求，当然，你亦可通过对源码的修改（增改规则），以获得更好的效果。
4.程序的思路已写在此，时间比较充裕的朋友，建议自己编写程序。真需要购买的，偶亦很欢迎，但购买前请参照以上1~3条。
5.有意购买者，可联系Email：171630607@qq.com，QQ：171630607。请尊重劳动成果，勿传播源码。
6.有朋友说，例子程序在WIN7 64bit上无法运行。经测试，例子程序在XP、WIN7 32bit可以运行，WIN7 64bit和WIN8 64bit不能运行。原因是例子程序做了加密处理，未经加密的源码在以上系统均可正常运行。
</content>
    </entry>
    
     <entry>
        <title>Lucene.Net入门基础</title>
        <url>http://xuzhibin.com/post/2010/lucenenet-getstart/</url>
        <categories>
          <category>.net</category>
        </categories>
        <tags>
          <tag>lucene</tag>
        </tags>
        <content type="html">  简单的例子 //索引 Private void Index() { IndexWriter writer = new IndexWriter(@&amp;#34;E:\Index&amp;#34;, new StandardAnalyzer()); Document doc = new Document(); doc.Add(new Field(&amp;#34;Text&amp;#34;,&amp;#34;哦耶,美丽的姑娘。&amp;#34;, Field.Store.YES, Field.Index.TOKENIZED)); writer.AddDocument(doc); writer.Close(); } //搜索 Private void Search(string words) { IndexSearcher searcher = new IndexSearcher(@&amp;#34;E:\Index&amp;#34;); Query query = new QueryParser(“Text”, new StandardAnalyzer()).Parse(words); Hits hits = searcher.Search(query); for (int i = 0; i &amp;lt; hits.Length(); i&#43;&#43;) System.Console.WriteLine(hits.Doc(i).GetField(&amp;#34;Text&amp;#34;).StringValue(); searcher.Close(); }  初识Lucene Lucene是什么 Lucene是一个高性能的、可扩展的信息检索工具包。它只是Java类库，并不是现成的应用程序。它提供简单易用却十分强大的API接口，基于它你可以快速的构建功能强大的搜索程序（搜索引擎？）。当前最新版2.9.2.1。 什么是索引 为了实现快速的搜索，Lucene会首先将需要处理的数据以一种称为倒排索引（Inverted Index）的数据结构进行存储。怎样理解倒排索引呢？简单的说，倒排索引并不是回答“这个文档中包含哪些单词？”这个问题，而是经过优化以后用来快速回答“哪些文档包含词XX？”这个问题。就像需要给书籍整理一份供快速查找的目录一样，Lucene也得为需要被搜索的数据整理优化出一份索引文件(Index file)，而这个过程称之为“索引”(Indexing)。
Lucene的核心类 索引过程：
IndexWriter Directory Analyzer Document Field
搜索过程：
IndexSearcher Term Query TermQuery Hits
索引 索引过程的流程图 注:Lucene索引过程分为三个主要的操作阶段：将数据换转成文本、分析文本、并将分析过的文本保存到索引库中
基本的索引操作 添加索引 Document
Field（理解Field的参数）
异构Document
追加域
增量索引
删除索引 软删除，仅添加了删除标记。调用 IndexWriter.Optimize() 后真正删除。
IndexReader reader = IndexReader.Open(directory); // 删除指定序号(DocId)的 Document。 reader.Delete(123); // 删除包含指定 Term 的 Document。 reader.Delete(new Term(FieldValue, &amp;#34;Hello&amp;#34;)); // 恢复软删除。 reader.UndeleteAll(); reader.Close();  更新索引 事实上，Lucene没有更新索引的方法
更新 = 删除 &#43; 添加
提示：当删除和添加多个Document对象时，最好进行批量处理。这样做的速度总是比交替的删除和添加操作的速度快得多。
//只需将 create 参数设为 false，即可往现有索引库添加新数据。 Directory directory = FSDirectory.GetDirectory(&amp;#34;index&amp;#34;, false); IndexWriter writer = new IndexWriter(directory, analyzer, false); writer.AddDocument(doc1); writer.AddDocument(doc2); writer.Optimize(); writer.Close();  加权(boosing) 可以给 Document 和 Field 增加权重(Boost)，使其在搜索结果排名更加靠前。缺省情况下，搜索结果以 Document.Score 作为排序依据，该数值越大排名越靠前。Boost 缺省值为 1。
Score = Score * Boost
通过上面的公式，我们就可以设置不同的权重来影响排名。 如下面的例子中根据 VIP 级别设定不同的权重。
Document document = new Document(); switch (vip) { case VIP.Gold: document.SetBoost(2F); break; case VIP.Argentine: document.SetBoost(1.5F); break; }  只要 Boost 足够大，那么就可以让某个命中结果永远排第一位，这就是百度等网站的”收费排名”业务。
Directory 从指定目录打开已有索引库。
private Directory directory = FSDirectory.GetDirectory(&amp;#34;c:\index&amp;#34;, false);  将索引库载入内存，以提高搜索速度。
private Directory directory = new RAMDirectory(FSDirectory.GetDirectory(@&amp;#34;c:\index&amp;#34;, false)); //或 //private Directory directory = new RAMDirectory(c:\index&amp;#34;);  注意 FSDirectory.GetDirectory 的 create 参数，为 true 时将删除已有索引库文件，可以通过 IndexReader.IndexExists() 方法判断。
合并索引库 将 directory1 合并到 directory2 中。
Directory directory1 = FSDirectory.GetDirectory(&amp;#34;index1&amp;#34;, false); Directory directory2 = FSDirectory.GetDirectory(&amp;#34;index2&amp;#34;, false); IndexWriter writer = new IndexWriter(directory2, analyzer, false); writer.AddIndexes(new Directory[] { directory }); Console.WriteLine(writer.DocCount()); writer.Close();  优化索引  很简单，一个writer.Optimize()搞定，优化过程会降低索引的效率，优化结果提高搜索性能。不要时时Optimize()，优化一次就够了  批量向 FSDirectory 增加索引时，增大合并因子(mergeFactor )和最小文档合并数(minMergeDocs)有助于提高性能，减少索引时间。  IndexWriter writer = new IndexWriter(directory, analyzer, true); writer.maxFieldLength = 1000; // 字段最大长度 writer.mergeFactor = 1000; writer.minMergeDocs = 1000; for (int i = 0; i &amp;lt; 10000; i&#43;&#43;) { // Add Documentes... } writer.Optimize(); writer.Close();  利用 Lucene，在创建索引的工程中你可以充分利用机器的硬件资源来提高索引的效率。当你需要索引大量的文件时，你会注意到索引过程的瓶颈是在往磁盘上写索引文件的过程中。为了解决这个问题, Lucene 在内存中持有一块缓冲区。但我们如何控制 Lucene 的缓冲区呢？幸运的是，Lucene 的类 IndexWriter 提供了三个参数用来调整缓冲区的大小以及往磁盘上写索引文件的频率。
（1）合并因子 (mergeFactor)
这个参数决定了在 Lucene 的一个索引块中可以存放多少文档以及把磁盘上的索引块合并成一个大的索引块的频率。比如，如果合并因子的值是 10，那么当内存中的文档数达到 10 的时候所有的文档都必须写到磁盘上的一个新的索引块中。并且，如果磁盘上的索引块的隔数达到 10 的话，这 10 个索引块会被合并成一个新的索引块。这个参数的默认值是 10，如果需要索引的文档数非常多的话这个值将是非常不合适的。对批处理的索引来讲，为这个参数赋一个比较大的值会得到比较好的索引效果。
（2）最小合并文档数 (minMergeDocs)
这个参数也会影响索引的性能。它决定了内存中的文档数至少达到多少才能将它们写回磁盘。这个参数的默认值是10，如果你有足够的内存，那么将这个值尽量设的比较大一些将会显著的提高索引性能。
（3）最大合并文档数 (maxMergeDocs)
这个参数决定了一个索引块中的最大的文档数。它的默认值是 Integer.MAX_VALUE，将这个参数设置为比较大的值可以提高索引效率和检索速度，由于该参数的默认值是整型的最大值，所以我们一般不需要改动这个参数。
大数据量索引（并发性、多线程和锁机制） 多线程索引 共享对象（注：一个IndexWriter或IndexReader对象可以被多个线程所共享） 巧用RAMDirectory
安全锁 Lucene使用基于文件的锁 write.lock 禁用索引锁 (disableLuceneLocks=true)
并发访问的规则 任意数量的只读操作都可以同时执行。 在索引正在被修改时，我们也可以同时执行任意数量的只读操作。 在某一时刻，只允许执行一个修改索引的操作。
搜索 IndexSearcher 通过IndexSearcher执行搜索
两种构建IndexSearcher对象的方法： Directory对象与文件路径。 (前者是推荐的) Search()方法
Query 创建Query对象 使用QueryParset构建Query对象。（注：QueryParset把查询表达式转换成Lucene内置的查询类型。）
几个常用的内置类型：TermQuery、RangeQuery、PrefixQuery、BooleanQuery。
强悍的QueryParser Query类的toString()方法 布尔查询 （AND、 OR、 NOT） 例：a AND b(&#43;a &#43;b) a OR b(a b) a AND NOT b(&#43;a -b)
组合查询 圆括号”()” 例： (a OR b) AND c
域的选择 例：tag:美女
范围查询 [ TO ] 和{ TO } 例：price:[100 TO 200] price:{100 TO 200}
……
(注：强悍，但不建议使用它)
Hits 使用Hits对象访问搜索结果 Hits类的几个方法 Length() Hits对象集合中所包含的文档的数量
Document(n) 排名第n的Document实例
Id(n) 排名第n的DocumentID
Score(n) 排名第n的标准分值
排序 使用Sort对象排序 通过 SortField 的构造参数，我们可以设置排序字段，排序条件，以及倒排。
Sort sort = new Sort(new SortField(FieldName, SortField.DOC, false)); IndexSearcher searcher = new IndexSearcher(reader); Hits hits = searcher.Search(query, sort);  按照索引顺序(索引时的文档ID)排序 使用Sort.INDEXORDER作为参数
多域排序 排序对性能的影响 排序对搜索速度影响还是很大的，尽可能不要使用多个排序条件。
建议：采用默认的积分排序,设计良好的加权机制
过滤 过滤(Filtering)是Lucene中用于缩小搜索空间的一种机制。
DateFliter 只限于指定日期域的值在某一时间范围
QueryFilter 把查询作果作为另一个新查询可搜索的文档空间。
建议：过滤器采取的是对搜索结果的再处理方式，会使程序的性能显著下降，一般推荐使用BooleanQuery组合更多的搜索条件来达成效果。
例子：
我们搜索上架时间在 2005-10-1 到 2005-10-30 之间的商品。
对于日期时间，我们需要转换一下才能添加到索引库，同时还必须是索引字段。
// index document.Add(FieldDate, DateField.DateToString(date), Field.Store.YES, Field.Index.UN_TOKENIZED); //... // search Filter filter = new DateFilter(FieldDate, DateTime.Parse(&amp;#34;2005-10-1&amp;#34;), DateTime.Parse(&amp;#34;2005-10-30&amp;#34;)); Hits hits = searcher.Search(query, filter);  除了日期时间，还可以使用整数。比如搜索价格在 100 ~ 200 之间的商品。
Lucene.Net NumberTools 对于数字进行了补位处理，如果需要使用浮点数可以自己参考源码进行。
// index document.Add(new Field(FieldNumber, NumberTools.LongToString((long)price), Field.Store.YES, Field.Index.UN_TOKENIZED)); //... // search Filter filter = new RangeFilter(FieldNumber, NumberTools.LongToString(100L), NumberTools.LongToString(200L), true, true); Hits hits = searcher.Search(query, filter); 使用 Query 作为过滤条件。 QueryFilter filter = new QueryFilter(QueryParser.Parse(&amp;#34;name2&amp;#34;, FieldValue, analyzer));  我们还可以使用 FilteredQuery 进行多条件过滤。
Filter filter = new DateFilter(FieldDate, DateTime.Parse(&amp;#34;2005-10-10&amp;#34;), DateTime.Parse(&amp;#34;2005-10-15&amp;#34;)); Filter filter2 = new RangeFilter(FieldNumber, NumberTools.LongToString(11L), NumberTools.LongToString(13L), true, true); Query query = QueryParser.Parse(&amp;#34;name*&amp;#34;, FieldName, analyzer); query = new FilteredQuery(query, filter); query = new FilteredQuery(query, filter2); IndexSearcher searcher = new IndexSearcher(reader); Hits hits = searcher.Search(query);  多域搜索 使用MultiFieldQueryParser实现多域搜索
权重影响域的优先级，而不是域的使用顺序
Query query = MultiFieldQueryParser.Parse(&amp;#34;name*&amp;#34;, new string[] { FieldName, FieldValue }, analyzer); IndexReader reader = IndexReader.Open(directory); IndexSearcher searcher = new IndexSearcher(reader); Hits hits = searcher.Search(query);  组合搜索 除了使用 QueryParser.Parse 分解复杂的搜索语法外，还可以通过组合多个 Query 来达到目的。
Query query1 = new TermQuery(new Term(FieldValue, &amp;#34;name1&amp;#34;)); //词语搜索 Query query2 = new WildcardQuery(new Term(FieldName, &amp;#34;name*&amp;#34;)); //通配符 Query query3 = new PrefixQuery(new Term(FieldName, &amp;#34;name1&amp;#34;)); //字段搜索 Field:Keyword，自动在结尾添加 * Query query4 = new RangeQuery(new Term(FieldNumber, NumberTools.LongToString(11L)), new Term(FieldNumber, NumberTools.LongToString(13L)), true); //范围搜索 Query query5 = new FilteredQuery(query, filter); //带过滤条件的搜索  BooleanQuery query = new BooleanQuery(); query.Add(query1, BooleanClause.Occur.MUST); query.Add(query2, BooleanClause.Occur.MUST); IndexSearcher searcher = new IndexSearcher(reader); Hits hits = searcher.Search(query);  分布搜索 我们可以使用 MultiReader 或 MultiSearcher 搜索多个索引库。
MultiReader reader = new MultiReader(new IndexReader[] { IndexReader.Open(@&amp;#34;c:\index&amp;#34;), IndexReader.Open(@&amp;#34;\\server\index&amp;#34;) }); IndexSearcher searcher = new IndexSearcher(reader); Hits hits = searcher.Search(query);  或
IndexSearcher searcher1 = new IndexSearcher(reader1); IndexSearcher searcher2 = new IndexSearcher(reader2); MultiSearcher searcher = new MultiSearcher(new Searchable[] { searcher1, searcher2 }); Hits hits = searcher.Search(query);  还可以使用 ParallelMultiSearcher 进行多线程并行搜索。
显示搜索语法字符串 我们组合了很多种搜索条件，或许想看看与其对等的搜索语法串是什么样的。
BooleanQuery query = new BooleanQuery(); query.Add(query1, true, false); query.Add(query2, true, false); //... Console.WriteLine(&amp;#34;Syntax: {0}&amp;#34;, query.ToString()); 输出： Syntax: &#43;(name:name* value:name*) &#43;number:[0000000000000000b TO 0000000000000000d]  分词 何谓分析器 分析(Analysis)，在Lucene当中指的是将域(Field)文本转换为最基本的索引单元——项(Term)的过程。
内置的分析器 KeywordAnalyzer SimpleAnalyzer StopAnalyzer WhitespaceAnalyzer StandardAnalyzer (最强大的了)
中文分词 官方没有自带的中文分词，可以选择第三方的开源中文分词，如盘古分词
例子源码下载 SourceCode
PS：例子程序采用的的Lucene.Net版本为2.9.2.1，文中所举例子程序未必能兼容最新版本，用法请以例子程序为准。 例子程序采用的中文分词为盘古分词。其官网为http://pangusegment.codeplex.com/
参考资料: 王振春同学的Lucene.Net培训资料 [Lucene.Net] 基本用法 http://www.rainsts.net/article.asp?id=313
</content>
    </entry>
    
     <entry>
        <title>CentOS安装crontab及使用方法</title>
        <url>http://xuzhibin.com/post/2010/install-crontab/</url>
        <categories>
          <category>server</category>
        </categories>
        <tags>
          <tag>crontab</tag>
        </tags>
        <content type="html"> 安装crontab:
[root@CentOS ~] yum install vixie-cron [root@CentOS ~] yum install crontabs 说明： vixie-cron软件包是cron的主程序；
crontabs软件包是用来安装、卸装、或列举用来驱动 cron 守护进程的表格的程序。
cron 是linux的内置服务，但它不自动起来，可以用以下的方法启动、关闭这个服务：
/sbin/service crond start #启动服务 /sbin/service crond stop #关闭服务 /sbin/service crond restart #重启服务 /sbin/service crond reload #重新载入配置 查看crontab服务状态：
service crond status 手动启动crontab服务：
service crond start 查看crontab服务是否已设置为开机启动，执行命令：
ntsysv 加入开机自动启动:
chkconfig --level 35 crond on</content>
    </entry>
    
     <entry>
        <title>.Net下开发Windows Service</title>
        <url>http://xuzhibin.com/post/2010/net-winservice/</url>
        <categories>
          <category>.net</category>
        </categories>
        <tags>
          <tag>service</tag>
        </tags>
        <content type="html">  Windows服务能做些什么？ Windows服务是这些后台程序、后台服务的正规名词。Windows服务的运行可以在没有用户干预的情况下，在后台运行，没有任何界面。通过Windows服务管理器进行管理。服务管理器也只能做些简单的操作：开始，暂停，继续，停止。Windows服务的特点：在后台运行，没有用户交互，可以随Windows启动而启动。
如何实现Windows服务？ 下面按”隔一定时间做一些相同的事情”的服务为例，说明Windows服务如何实现。
**1.先按普通Windows程序设计好你的程序逻辑。 **
建立一个空白解决方案WindowsService.sln
添加Windows类库项目ServiceBLL.csproj
将Class1.cs改名为AppBLL.cs
添加一个方法Dothings()，这个方法用来每隔一段时间调用一次，做些周期性的事情。
namespace ServiceBLL { public class AppBLL { public void Dothings() { //隔一段时间调用一次  LogHelper.WriteLog(&amp;#34;test&amp;#34;); } } }  **2.向解决方案添加一个WindowsService.csproj **
将Service1.cs重命名为Service.cs
给WindowsService添加ServiceBLL项目引用
打开Service.cs代码视图，向Service类添加成员
ServiceBLL.AppBLL appBLL;
在构造函数里面对appBLL实例化
appBLL= new AppBLL ();
在using位置添加System.Theading
using System.Threading;
给Service类添加计时器
Timer serviceTimer;
添加TimeCallback方法，用于计时器调用
public void TimerCallback(object obj) { //隔一段时间调用一次  appBLL.Dothings(); }  在OnStart()方法中添加方法，用于启动计时器
serviceTimer = new Timer(new TimerCallback(TimerCallback), state, 0, period);
此处，state用于保存状态，如果不需要，保存状态，可以传入null。第三个参数0表示立即调用TimerCallback方法，如果不需要立即调用，可以传入period。period是计时器的计时间隔，单位为毫秒。
重载 OnPause ()和OnContinue ()方法，对计时器进行控制。
Service.cs代码如下
using System.ServiceProcess; using System.Threading; using ServiceBLL; namespace WindowsService { public partial class Service : ServiceBase { private Timer serviceTimer; private AppBLL appBLL; private int period; private object state; public Service() { InitializeComponent(); appBLL = new AppBLL(); } protected override void OnStart(string[] args) { //启动timer  period = 10*1000;//10秒，可从配置文件中获取  serviceTimer = new Timer(new TimerCallback(TimerCallback), state, 0, period); LogHelper.WriteLog(&amp;#34;OnStart&amp;#34;); } protected override void OnStop() { //停止计时器  serviceTimer.Change(Timeout.Infinite, Timeout.Infinite); LogHelper.WriteLog(&amp;#34;OnStop&amp;#34;); } protected override void OnContinue() { //重新开始计时  serviceTimer.Change(0, period); LogHelper.WriteLog(&amp;#34;OnContinue&amp;#34;); } protected override void OnPause() { //停止计时器  serviceTimer.Change(Timeout.Infinite, Timeout.Infinite); LogHelper.WriteLog(&amp;#34;OnPause&amp;#34;); } public void TimerCallback(object obj) { //隔一段时间调用一次  appBLL.Dothings(); } } }  Program.cs代码如下
static class Program { /// &amp;lt;summary&amp;gt;  /// 应用程序的主入口点。  /// &amp;lt;/summary&amp;gt;  static void Main() { ServiceBase[] ServicesToRun; ServicesToRun = new ServiceBase[] { new Service() }; ServiceBase.Run(ServicesToRun); } }  **3.将这个服务程序切换到设计视图 **
右击设计视图选择”添加安装程序”
切换到刚被添加的ProjectInstaller的设计视图
设置serviceInstaller1组件的属性：
1) ServiceName = My Sample Service
2) StartType = Automatic (开机自动运行)
设置serviceProcessInstaller1组件的属性 Account = LocalSystem
**4.安装和卸载服务 **
1) 手动安装服务
访问项目中的已编译可执行文件所在的目录。
用项目的输出作为参数，从命令行运行
InstallUtil.exe。在命令行中输入下列代码：
installutil yourproject.exe
2) 手动卸载服务
用项目的输出作为参数，从命令行运行
InstallUtil.exe。在命令行中输入下列代码：
installutil /u yourproject.exe
另一种方法：从命令行运行 sc delete 服务名
3)安装Windows服务的批命令如下:
@ECHO OFF REM The following directory is for .NET2.0 set DOTNETFX=%SystemRoot%\Microsoft.NET\Framework\v2.0.50727 set PATH=%PATH%;%DOTNETFX% cd\ cd &amp;#34;H:\Net_Work\Madnet\Demo\WindowsService\WindowsService\bin\Debug&amp;#34; echo 正在安装 测试服务... echo --------------------------------------------------- InstallUtil /i WindowsService.exe echo --------------------------------------------------- echo Done. exit 4)卸载Windows服务的批命令如下：
@ECHO OFF REM The following directory is for .NET2.0 set DOTNETFX=%SystemRoot%\Microsoft.NET\Framework\v2.0.50727 set PATH=%PATH%;%DOTNETFX% cd\ cd &amp;#34;H:\Net_Work\Madnet\Demo\WindowsService\WindowsService\bin\Debug&amp;#34; echo 正在卸载 测试服务... echo --------------------------------------------------- InstallUtil /U WindowsService.exe echo --------------------------------------------------- echo Done. exit 5.调试服务
1)安装您的服务。
2)可从服务控制管理器、”服务器资源管理器”或代码启动服务。
3) 用Visual Studio装载这个项目，从”调试”菜单中选择”进程”。出现”进程”对话框。
4)单击”显示系统进程”。
5)在”可用进程”区域内单击服务的进程，然后单击”附加”。（提示 此进程将与服务的可执行文件同名。）出现”附加到进程”对话框。
6)选择任意适当选项，然后单击”确定”关闭对话框。（注意 您现在已处于调试模式。）
7)设置要在代码中使用的任意断点。
8)访问服务控制管理器并操纵您的服务，并发送停止、暂停和继续命令以命中您的断点
源文件下载
</content>
    </entry>
    
     <entry>
        <title>大规模网站架构</title>
        <url>http://xuzhibin.com/post/2009/web-architecture/</url>
        <categories>
          <category>research</category>
        </categories>
        <tags>
          <tag>架构</tag>
        </tags>
        <content type="html">  以下并非所有都经过本人实践,部分为根据资料的假想所得,切勿贯彻本本主义。
网站架构目标  高可用性(High Availability) 可伸缩性(Scalability) 高性能(High Performance)  原则  尽量避免分布式，此为分布式第一原则 避免分布式事务  系统异构  架构与语言无关 系统可以多个平台并存(分层,模块化)  数据库 数据库读写分离  直接在程序中实现,或封装为ORM MySQL Proxy  数据库纵横切分 水平切分  根据自定义策略,如hash(N)%n(按hash分),查找表 在水平分库时，应优先考虑从属关系，以降低查询的复杂度。如用户A和用户A所发表的文章应分在同一数据库中。 如有用到user_id，则应该在公共库中创建一个路由表，表字段主要有：user_id,user_name,DB_Name。如没有用到user_id，而是根据user_name判断及查询用户的关系，则可省略路由表，根据某种算法进行DB定位，此时应考虑以后增加节点时，DB定位是否会发生变化的情况。 为避免分表时自增id发生重复的情况，可选择以下的几个方法： &amp;gt; 1.在公共库创建一个空表，专门用于id分发。
 2.利用递增值，如DB1的递增值为2，DB2的递增值为3，DB3的递增值为5…
3.利用初始值，id长度一般为11位，每个DB取9位（最多100个DB），如DB1的起始值为100000000，DB2的起始值为200000000，DB3的起始值为300000000…
  – 在系统设计时就考虑数据库切分的话，应先在一台服务器创建多个数据库节点，当负载达到一定程度时，再将节点迁移至其他服务器上，这样可以减少数据迁移的工作量。每次增加数据库节点，原则上应为已有节点的倍数，而不是一台台的增加。
垂直切分  按功能分(论坛，博客）  表分区 非关系数据库(NoSQL) 高性能  Redis Memcached 海量存储 MongoDB
  负载均衡 DNS负载均衡 反向代理负载均衡 负载均衡软件  nginx HAProxy apache httpd LVS(网络第四层工作) F5(硬件，四层/七层)  高可用性  使用双机热备 故障时切换至备份机 工具(Linux-HA) heartbeat  缓存 按功能分  数据缓存 页面缓存 页面片段缓存 静态化 浏览器缓存  按存储介质分  本地缓存 分布式缓存 &amp;gt; memcached  反向代理缓存  squid 巨无霸 Varnish  静态资源分离 img,js,css使用单独的服务器处理请求  图片服务器的域名不同 多台机器保存相同的图片(img3,img2子域名) 同一页面不同图片随机生成不同的子域名进行负载均衡  FAQ A.一些大网站，图片服务器为什么都用另外一个域名? 比如yahoo.com 图片服务器用了yimg.com 的域名?
1.因为IE等浏览器对单一域名有并发限制
2.避免COOKIE 的影响,如taobao.com 域下的Cookie 信息不会被带到 taobaoimg.com 域下，提高了图片服务器解析 header 头的速度。
CDN 浏览器优化  节省带宽:js,css的静态gzip压缩 &amp;gt; http header: Content-Encoding: gzip 浏览器缓存 &amp;gt; http header: Etag,Last-Modified 小图片,css,js压缩,合并(JSA)  分布式Session  单点认证(SSO) session memcached db  分布式文件系统  MogileFS FastDFS  </content>
    </entry>
    
     <entry>
        <title>NVelocity直接使用字符串模板</title>
        <url>http://xuzhibin.com/post/2009/nvelocity-demo/</url>
        <categories>
          <category>.net</category>
        </categories>
        <tags>
          <tag>nvelocity</tag>
        </tags>
        <content type="html"> using System; using System.IO; using System.Collections; using System.Collections.Generic; using NVelocity; using NVelocity.App; namespace ConsoleApplication1 { class Program { static void Main(string[] args) { string templates = &amp;#34;Hi $name $surname, The date is $date.&amp;#34;; Dictionary oo = new Dictionary(); oo.Add(&amp;#34;name&amp;#34;, &amp;#34;Joe&amp;#34;); oo.Add(&amp;#34;surname&amp;#34;, &amp;#34;Smith&amp;#34;); oo.Add(&amp;#34;date&amp;#34;, DateTime.Now.ToString(&amp;#34;D&amp;#34;)); Console.WriteLine(Fill(templates,oo)); Console.ReadLine(); } static public string Fill(string template, IDictionary values) { var engine = new VelocityEngine(); engine.Init(); var context = new VelocityContext(); if (values != null) foreach (string k in values.Keys) { context.Put(k, values[k]); } using (var writer = new StringWriter()) { engine.Evaluate(context, writer, &amp;#34;&amp;#34;, template); return writer.GetStringBuilder().ToString(); } } } } </content>
    </entry>
    
     <entry>
        <title>一段广告加载代码</title>
        <url>http://xuzhibin.com/post/2008/adload/</url>
        <categories>
          <category>ui</category>
        </categories>
        <tags>
          <tag>广告</tag>
        </tags>
        <content type="html"> var arr = { &amp;#34;default&amp;#34; : &amp;#34;http://dpvc.39.net/adpolestar/door/;ap=5E30CD32_CA9F _8CC4_BD09_09CE939700E0;ct=if;pu=san9;/?&amp;#34; } var Html = { load: function() { var s=document.getElementById(&amp;#34;show_drug&amp;#34;); if(typeof(s)==&amp;#34;undefined&amp;#34;||s==null) return arr[&amp;#34;default&amp;#34;]; var code = s.src.replace(/^.&#43;\?/,&amp;#39;&amp;#39;); code=decodeURI(code); if(typeof(arr[code])!=&amp;#34;undefined&amp;#34;) return arr[code]; var index; while((index=code.lastIndexOf(&amp;#39;_&amp;#39;))!=-1){ code=code.substring(0,index); if(typeof(arr[code])!=&amp;#34;undefined&amp;#34;) { return arr[code]; } } return arr[&amp;#34;default&amp;#34;]; } } document.getElementById(&amp;#34;drug_tl&amp;#34;).innerHTML = &amp;#34;&amp;lt;iframe SRC=&amp;#39;&amp;#34;&#43;Html.load()&#43;&amp;#34;&amp;#39; NAME=&amp;#39;adFrame&amp;#39; WIDTH=&amp;#39;970&amp;#39; HEIGHT=&amp;#39;90&amp;#39; FRAMEBORDER=&amp;#39;no&amp;#39; BORDER=&amp;#39;0&amp;#39; MARGINWIDTH=&amp;#39;0&amp;#39; MARGINHEIGHT=&amp;#39;0&amp;#39; SCROLLING=&amp;#39;no&amp;#39;&amp;gt;&amp;lt;/iframe&amp;gt;&amp;#34;;  注：show_drug为js id，如
&amp;lt;script id=&amp;#34;show_drug&amp;#34; type=&amp;#34;text/javascript&amp;#34; language=&amp;#34;javascript&amp;#34; src=&amp;#34;http://img.39.net/js/db/show_drug.js?%e4%ba%a7%e5%93%81_%e8% 8d%af%e5%93%81_%e4%b8%ad%e6%88%90_%e7%97%94%e7%96%ae&amp;#34;&amp;gt;&amp;lt;/script&amp;gt;</content>
    </entry>
    
</search>